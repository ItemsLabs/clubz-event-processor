// Code generated by SQLBoiler 4.16.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package schema

import (
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/v4/types"
	"github.com/volatiletech/strmangle"
)

// CardPackType is an object representing the database table.
type CardPackType struct {
	ID           string      `boil:"id" json:"id" toml:"id" yaml:"id"`
	CreatedAt    time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt    time.Time   `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`
	Name         string      `boil:"name" json:"name" toml:"name" yaml:"name"`
	Description  null.String `boil:"description" json:"description,omitempty" toml:"description" yaml:"description,omitempty"`
	Image        null.String `boil:"image" json:"image,omitempty" toml:"image" yaml:"image,omitempty"`
	Tier1        types.JSON  `boil:"tier1" json:"tier1" toml:"tier1" yaml:"tier1"`
	Tier2        types.JSON  `boil:"tier2" json:"tier2" toml:"tier2" yaml:"tier2"`
	Tier3        types.JSON  `boil:"tier3" json:"tier3" toml:"tier3" yaml:"tier3"`
	Tier4        types.JSON  `boil:"tier4" json:"tier4" toml:"tier4" yaml:"tier4"`
	Tier5        types.JSON  `boil:"tier5" json:"tier5" toml:"tier5" yaml:"tier5"`
	PackLimits   null.Int    `boil:"pack_limits" json:"pack_limits,omitempty" toml:"pack_limits" yaml:"pack_limits,omitempty"`
	CardPackCode null.String `boil:"card_pack_code" json:"card_pack_code,omitempty" toml:"card_pack_code" yaml:"card_pack_code,omitempty"`
	Rarities     null.JSON   `boil:"rarities" json:"rarities,omitempty" toml:"rarities" yaml:"rarities,omitempty"`
	StarRatings  null.JSON   `boil:"star_ratings" json:"star_ratings,omitempty" toml:"star_ratings" yaml:"star_ratings,omitempty"`
	Collection   null.String `boil:"collection" json:"collection,omitempty" toml:"collection" yaml:"collection,omitempty"`

	R *cardPackTypeR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L cardPackTypeL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var CardPackTypeColumns = struct {
	ID           string
	CreatedAt    string
	UpdatedAt    string
	Name         string
	Description  string
	Image        string
	Tier1        string
	Tier2        string
	Tier3        string
	Tier4        string
	Tier5        string
	PackLimits   string
	CardPackCode string
	Rarities     string
	StarRatings  string
	Collection   string
}{
	ID:           "id",
	CreatedAt:    "created_at",
	UpdatedAt:    "updated_at",
	Name:         "name",
	Description:  "description",
	Image:        "image",
	Tier1:        "tier1",
	Tier2:        "tier2",
	Tier3:        "tier3",
	Tier4:        "tier4",
	Tier5:        "tier5",
	PackLimits:   "pack_limits",
	CardPackCode: "card_pack_code",
	Rarities:     "rarities",
	StarRatings:  "star_ratings",
	Collection:   "collection",
}

var CardPackTypeTableColumns = struct {
	ID           string
	CreatedAt    string
	UpdatedAt    string
	Name         string
	Description  string
	Image        string
	Tier1        string
	Tier2        string
	Tier3        string
	Tier4        string
	Tier5        string
	PackLimits   string
	CardPackCode string
	Rarities     string
	StarRatings  string
	Collection   string
}{
	ID:           "card_pack_types.id",
	CreatedAt:    "card_pack_types.created_at",
	UpdatedAt:    "card_pack_types.updated_at",
	Name:         "card_pack_types.name",
	Description:  "card_pack_types.description",
	Image:        "card_pack_types.image",
	Tier1:        "card_pack_types.tier1",
	Tier2:        "card_pack_types.tier2",
	Tier3:        "card_pack_types.tier3",
	Tier4:        "card_pack_types.tier4",
	Tier5:        "card_pack_types.tier5",
	PackLimits:   "card_pack_types.pack_limits",
	CardPackCode: "card_pack_types.card_pack_code",
	Rarities:     "card_pack_types.rarities",
	StarRatings:  "card_pack_types.star_ratings",
	Collection:   "card_pack_types.collection",
}

// Generated where

type whereHelpertypes_JSON struct{ field string }

func (w whereHelpertypes_JSON) EQ(x types.JSON) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.EQ, x)
}
func (w whereHelpertypes_JSON) NEQ(x types.JSON) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.NEQ, x)
}
func (w whereHelpertypes_JSON) LT(x types.JSON) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertypes_JSON) LTE(x types.JSON) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertypes_JSON) GT(x types.JSON) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertypes_JSON) GTE(x types.JSON) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelpernull_Int struct{ field string }

func (w whereHelpernull_Int) EQ(x null.Int) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Int) NEQ(x null.Int) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Int) LT(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Int) LTE(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Int) GT(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Int) GTE(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelpernull_Int) IN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelpernull_Int) NIN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

func (w whereHelpernull_Int) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Int) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

var CardPackTypeWhere = struct {
	ID           whereHelperstring
	CreatedAt    whereHelpertime_Time
	UpdatedAt    whereHelpertime_Time
	Name         whereHelperstring
	Description  whereHelpernull_String
	Image        whereHelpernull_String
	Tier1        whereHelpertypes_JSON
	Tier2        whereHelpertypes_JSON
	Tier3        whereHelpertypes_JSON
	Tier4        whereHelpertypes_JSON
	Tier5        whereHelpertypes_JSON
	PackLimits   whereHelpernull_Int
	CardPackCode whereHelpernull_String
	Rarities     whereHelpernull_JSON
	StarRatings  whereHelpernull_JSON
	Collection   whereHelpernull_String
}{
	ID:           whereHelperstring{field: "\"card_pack_types\".\"id\""},
	CreatedAt:    whereHelpertime_Time{field: "\"card_pack_types\".\"created_at\""},
	UpdatedAt:    whereHelpertime_Time{field: "\"card_pack_types\".\"updated_at\""},
	Name:         whereHelperstring{field: "\"card_pack_types\".\"name\""},
	Description:  whereHelpernull_String{field: "\"card_pack_types\".\"description\""},
	Image:        whereHelpernull_String{field: "\"card_pack_types\".\"image\""},
	Tier1:        whereHelpertypes_JSON{field: "\"card_pack_types\".\"tier1\""},
	Tier2:        whereHelpertypes_JSON{field: "\"card_pack_types\".\"tier2\""},
	Tier3:        whereHelpertypes_JSON{field: "\"card_pack_types\".\"tier3\""},
	Tier4:        whereHelpertypes_JSON{field: "\"card_pack_types\".\"tier4\""},
	Tier5:        whereHelpertypes_JSON{field: "\"card_pack_types\".\"tier5\""},
	PackLimits:   whereHelpernull_Int{field: "\"card_pack_types\".\"pack_limits\""},
	CardPackCode: whereHelpernull_String{field: "\"card_pack_types\".\"card_pack_code\""},
	Rarities:     whereHelpernull_JSON{field: "\"card_pack_types\".\"rarities\""},
	StarRatings:  whereHelpernull_JSON{field: "\"card_pack_types\".\"star_ratings\""},
	Collection:   whereHelpernull_String{field: "\"card_pack_types\".\"collection\""},
}

// CardPackTypeRels is where relationship names are stored.
var CardPackTypeRels = struct {
	AssignedCardPacks string
}{
	AssignedCardPacks: "AssignedCardPacks",
}

// cardPackTypeR is where relationships are stored.
type cardPackTypeR struct {
	AssignedCardPacks AssignedCardPackSlice `boil:"AssignedCardPacks" json:"AssignedCardPacks" toml:"AssignedCardPacks" yaml:"AssignedCardPacks"`
}

// NewStruct creates a new relationship struct
func (*cardPackTypeR) NewStruct() *cardPackTypeR {
	return &cardPackTypeR{}
}

func (r *cardPackTypeR) GetAssignedCardPacks() AssignedCardPackSlice {
	if r == nil {
		return nil
	}
	return r.AssignedCardPacks
}

// cardPackTypeL is where Load methods for each relationship are stored.
type cardPackTypeL struct{}

var (
	cardPackTypeAllColumns            = []string{"id", "created_at", "updated_at", "name", "description", "image", "tier1", "tier2", "tier3", "tier4", "tier5", "pack_limits", "card_pack_code", "rarities", "star_ratings", "collection"}
	cardPackTypeColumnsWithoutDefault = []string{"id", "created_at", "updated_at", "name", "tier1", "tier2", "tier3", "tier4", "tier5"}
	cardPackTypeColumnsWithDefault    = []string{"description", "image", "pack_limits", "card_pack_code", "rarities", "star_ratings", "collection"}
	cardPackTypePrimaryKeyColumns     = []string{"id"}
	cardPackTypeGeneratedColumns      = []string{}
)

type (
	// CardPackTypeSlice is an alias for a slice of pointers to CardPackType.
	// This should almost always be used instead of []CardPackType.
	CardPackTypeSlice []*CardPackType

	cardPackTypeQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	cardPackTypeType                 = reflect.TypeOf(&CardPackType{})
	cardPackTypeMapping              = queries.MakeStructMapping(cardPackTypeType)
	cardPackTypePrimaryKeyMapping, _ = queries.BindMapping(cardPackTypeType, cardPackTypeMapping, cardPackTypePrimaryKeyColumns)
	cardPackTypeInsertCacheMut       sync.RWMutex
	cardPackTypeInsertCache          = make(map[string]insertCache)
	cardPackTypeUpdateCacheMut       sync.RWMutex
	cardPackTypeUpdateCache          = make(map[string]updateCache)
	cardPackTypeUpsertCacheMut       sync.RWMutex
	cardPackTypeUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// One returns a single cardPackType record from the query.
func (q cardPackTypeQuery) One(exec boil.Executor) (*CardPackType, error) {
	o := &CardPackType{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(nil, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "schema: failed to execute a one query for card_pack_types")
	}

	return o, nil
}

// All returns all CardPackType records from the query.
func (q cardPackTypeQuery) All(exec boil.Executor) (CardPackTypeSlice, error) {
	var o []*CardPackType

	err := q.Bind(nil, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "schema: failed to assign all query results to CardPackType slice")
	}

	return o, nil
}

// Count returns the count of all CardPackType records in the query.
func (q cardPackTypeQuery) Count(exec boil.Executor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "schema: failed to count card_pack_types rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q cardPackTypeQuery) Exists(exec boil.Executor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "schema: failed to check if card_pack_types exists")
	}

	return count > 0, nil
}

// AssignedCardPacks retrieves all the assigned_card_pack's AssignedCardPacks with an executor.
func (o *CardPackType) AssignedCardPacks(mods ...qm.QueryMod) assignedCardPackQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"assigned_card_packs\".\"card_pack_type_id\"=?", o.ID),
	)

	return AssignedCardPacks(queryMods...)
}

// LoadAssignedCardPacks allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (cardPackTypeL) LoadAssignedCardPacks(e boil.Executor, singular bool, maybeCardPackType interface{}, mods queries.Applicator) error {
	var slice []*CardPackType
	var object *CardPackType

	if singular {
		var ok bool
		object, ok = maybeCardPackType.(*CardPackType)
		if !ok {
			object = new(CardPackType)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeCardPackType)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeCardPackType))
			}
		}
	} else {
		s, ok := maybeCardPackType.(*[]*CardPackType)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeCardPackType)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeCardPackType))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &cardPackTypeR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &cardPackTypeR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`assigned_card_packs`),
		qm.WhereIn(`assigned_card_packs.card_pack_type_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load assigned_card_packs")
	}

	var resultSlice []*AssignedCardPack
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice assigned_card_packs")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on assigned_card_packs")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for assigned_card_packs")
	}

	if singular {
		object.R.AssignedCardPacks = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &assignedCardPackR{}
			}
			foreign.R.CardPackType = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.CardPackTypeID {
				local.R.AssignedCardPacks = append(local.R.AssignedCardPacks, foreign)
				if foreign.R == nil {
					foreign.R = &assignedCardPackR{}
				}
				foreign.R.CardPackType = local
				break
			}
		}
	}

	return nil
}

// AddAssignedCardPacks adds the given related objects to the existing relationships
// of the card_pack_type, optionally inserting them as new records.
// Appends related to o.R.AssignedCardPacks.
// Sets related.R.CardPackType appropriately.
func (o *CardPackType) AddAssignedCardPacks(exec boil.Executor, insert bool, related ...*AssignedCardPack) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.CardPackTypeID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"assigned_card_packs\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"card_pack_type_id"}),
				strmangle.WhereClause("\"", "\"", 2, assignedCardPackPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.CardPackTypeID = o.ID
		}
	}

	if o.R == nil {
		o.R = &cardPackTypeR{
			AssignedCardPacks: related,
		}
	} else {
		o.R.AssignedCardPacks = append(o.R.AssignedCardPacks, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &assignedCardPackR{
				CardPackType: o,
			}
		} else {
			rel.R.CardPackType = o
		}
	}
	return nil
}

// CardPackTypes retrieves all the records using an executor.
func CardPackTypes(mods ...qm.QueryMod) cardPackTypeQuery {
	mods = append(mods, qm.From("\"card_pack_types\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"card_pack_types\".*"})
	}

	return cardPackTypeQuery{q}
}

// FindCardPackType retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindCardPackType(exec boil.Executor, iD string, selectCols ...string) (*CardPackType, error) {
	cardPackTypeObj := &CardPackType{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"card_pack_types\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(nil, exec, cardPackTypeObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "schema: unable to select from card_pack_types")
	}

	return cardPackTypeObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *CardPackType) Insert(exec boil.Executor, columns boil.Columns) error {
	if o == nil {
		return errors.New("schema: no card_pack_types provided for insertion")
	}

	var err error
	currTime := time.Now().In(boil.GetLocation())

	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}
	if o.UpdatedAt.IsZero() {
		o.UpdatedAt = currTime
	}

	nzDefaults := queries.NonZeroDefaultSet(cardPackTypeColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	cardPackTypeInsertCacheMut.RLock()
	cache, cached := cardPackTypeInsertCache[key]
	cardPackTypeInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			cardPackTypeAllColumns,
			cardPackTypeColumnsWithDefault,
			cardPackTypeColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(cardPackTypeType, cardPackTypeMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(cardPackTypeType, cardPackTypeMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"card_pack_types\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"card_pack_types\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "schema: unable to insert into card_pack_types")
	}

	if !cached {
		cardPackTypeInsertCacheMut.Lock()
		cardPackTypeInsertCache[key] = cache
		cardPackTypeInsertCacheMut.Unlock()
	}

	return nil
}

// Update uses an executor to update the CardPackType.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *CardPackType) Update(exec boil.Executor, columns boil.Columns) (int64, error) {
	currTime := time.Now().In(boil.GetLocation())

	o.UpdatedAt = currTime

	var err error
	key := makeCacheKey(columns, nil)
	cardPackTypeUpdateCacheMut.RLock()
	cache, cached := cardPackTypeUpdateCache[key]
	cardPackTypeUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			cardPackTypeAllColumns,
			cardPackTypePrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("schema: unable to update card_pack_types, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"card_pack_types\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, cardPackTypePrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(cardPackTypeType, cardPackTypeMapping, append(wl, cardPackTypePrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	var result sql.Result
	result, err = exec.Exec(cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to update card_pack_types row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "schema: failed to get rows affected by update for card_pack_types")
	}

	if !cached {
		cardPackTypeUpdateCacheMut.Lock()
		cardPackTypeUpdateCache[key] = cache
		cardPackTypeUpdateCacheMut.Unlock()
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values.
func (q cardPackTypeQuery) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to update all for card_pack_types")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to retrieve rows affected for card_pack_types")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o CardPackTypeSlice) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("schema: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), cardPackTypePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"card_pack_types\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, cardPackTypePrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to update all in cardPackType slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to retrieve rows affected all in update all cardPackType")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *CardPackType) Upsert(exec boil.Executor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("schema: no card_pack_types provided for upsert")
	}
	currTime := time.Now().In(boil.GetLocation())

	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}
	o.UpdatedAt = currTime

	nzDefaults := queries.NonZeroDefaultSet(cardPackTypeColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	cardPackTypeUpsertCacheMut.RLock()
	cache, cached := cardPackTypeUpsertCache[key]
	cardPackTypeUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			cardPackTypeAllColumns,
			cardPackTypeColumnsWithDefault,
			cardPackTypeColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			cardPackTypeAllColumns,
			cardPackTypePrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("schema: unable to upsert card_pack_types, could not build update column list")
		}

		ret := strmangle.SetComplement(cardPackTypeAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(cardPackTypePrimaryKeyColumns) == 0 {
				return errors.New("schema: unable to upsert card_pack_types, could not build conflict column list")
			}

			conflict = make([]string, len(cardPackTypePrimaryKeyColumns))
			copy(conflict, cardPackTypePrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"card_pack_types\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(cardPackTypeType, cardPackTypeMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(cardPackTypeType, cardPackTypeMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "schema: unable to upsert card_pack_types")
	}

	if !cached {
		cardPackTypeUpsertCacheMut.Lock()
		cardPackTypeUpsertCache[key] = cache
		cardPackTypeUpsertCacheMut.Unlock()
	}

	return nil
}

// Delete deletes a single CardPackType record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *CardPackType) Delete(exec boil.Executor) (int64, error) {
	if o == nil {
		return 0, errors.New("schema: no CardPackType provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cardPackTypePrimaryKeyMapping)
	sql := "DELETE FROM \"card_pack_types\" WHERE \"id\"=$1"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to delete from card_pack_types")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "schema: failed to get rows affected by delete for card_pack_types")
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q cardPackTypeQuery) DeleteAll(exec boil.Executor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("schema: no cardPackTypeQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to delete all from card_pack_types")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "schema: failed to get rows affected by deleteall for card_pack_types")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o CardPackTypeSlice) DeleteAll(exec boil.Executor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), cardPackTypePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"card_pack_types\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, cardPackTypePrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to delete all from cardPackType slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "schema: failed to get rows affected by deleteall for card_pack_types")
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *CardPackType) Reload(exec boil.Executor) error {
	ret, err := FindCardPackType(exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *CardPackTypeSlice) ReloadAll(exec boil.Executor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := CardPackTypeSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), cardPackTypePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"card_pack_types\".* FROM \"card_pack_types\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, cardPackTypePrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(nil, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "schema: unable to reload all in CardPackTypeSlice")
	}

	*o = slice

	return nil
}

// CardPackTypeExists checks if the CardPackType row exists.
func CardPackTypeExists(exec boil.Executor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"card_pack_types\" where \"id\"=$1 limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}
	row := exec.QueryRow(sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "schema: unable to check if card_pack_types exists")
	}

	return exists, nil
}

// Exists checks if the CardPackType row exists.
func (o *CardPackType) Exists(exec boil.Executor) (bool, error) {
	return CardPackTypeExists(exec, o.ID)
}
