// Code generated by SQLBoiler 4.16.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package schema

import (
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// AppInbox is an object representing the database table.
type AppInbox struct {
	ID           string      `boil:"id" json:"id" toml:"id" yaml:"id"`
	Title        string      `boil:"title" json:"title" toml:"title" yaml:"title"`
	Description  string      `boil:"description" json:"description" toml:"description" yaml:"description"`
	Status       string      `boil:"status" json:"status" toml:"status" yaml:"status"`
	Priority     string      `boil:"priority" json:"priority" toml:"priority" yaml:"priority"`
	Category     string      `boil:"category" json:"category" toml:"category" yaml:"category"`
	ImageURL     null.String `boil:"image_url" json:"image_url,omitempty" toml:"image_url" yaml:"image_url,omitempty"`
	LinkURL      null.String `boil:"link_url" json:"link_url,omitempty" toml:"link_url" yaml:"link_url,omitempty"`
	CreatedAt    time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt    time.Time   `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`
	Read         bool        `boil:"read" json:"read" toml:"read" yaml:"read"`
	UserID       null.String `boil:"user_id" json:"user_id,omitempty" toml:"user_id" yaml:"user_id,omitempty"`
	Claimed      bool        `boil:"claimed" json:"claimed" toml:"claimed" yaml:"claimed"`
	ClamedAt     null.Time   `boil:"clamed_at" json:"clamed_at,omitempty" toml:"clamed_at" yaml:"clamed_at,omitempty"`
	RewardID     null.String `boil:"reward_id" json:"reward_id,omitempty" toml:"reward_id" yaml:"reward_id,omitempty"`
	Clear        bool        `boil:"clear" json:"clear" toml:"clear" yaml:"clear"`
	GameWeekIDID null.String `boil:"game_week_id_id" json:"game_week_id_id,omitempty" toml:"game_week_id_id" yaml:"game_week_id_id,omitempty"`
	MatchIDID    null.String `boil:"match_id_id" json:"match_id_id,omitempty" toml:"match_id_id" yaml:"match_id_id,omitempty"`
	GameID       null.String `boil:"game_id" json:"game_id,omitempty" toml:"game_id" yaml:"game_id,omitempty"`

	R *appInboxR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L appInboxL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var AppInboxColumns = struct {
	ID           string
	Title        string
	Description  string
	Status       string
	Priority     string
	Category     string
	ImageURL     string
	LinkURL      string
	CreatedAt    string
	UpdatedAt    string
	Read         string
	UserID       string
	Claimed      string
	ClamedAt     string
	RewardID     string
	Clear        string
	GameWeekIDID string
	MatchIDID    string
	GameID       string
}{
	ID:           "id",
	Title:        "title",
	Description:  "description",
	Status:       "status",
	Priority:     "priority",
	Category:     "category",
	ImageURL:     "image_url",
	LinkURL:      "link_url",
	CreatedAt:    "created_at",
	UpdatedAt:    "updated_at",
	Read:         "read",
	UserID:       "user_id",
	Claimed:      "claimed",
	ClamedAt:     "clamed_at",
	RewardID:     "reward_id",
	Clear:        "clear",
	GameWeekIDID: "game_week_id_id",
	MatchIDID:    "match_id_id",
	GameID:       "game_id",
}

var AppInboxTableColumns = struct {
	ID           string
	Title        string
	Description  string
	Status       string
	Priority     string
	Category     string
	ImageURL     string
	LinkURL      string
	CreatedAt    string
	UpdatedAt    string
	Read         string
	UserID       string
	Claimed      string
	ClamedAt     string
	RewardID     string
	Clear        string
	GameWeekIDID string
	MatchIDID    string
	GameID       string
}{
	ID:           "app_inbox.id",
	Title:        "app_inbox.title",
	Description:  "app_inbox.description",
	Status:       "app_inbox.status",
	Priority:     "app_inbox.priority",
	Category:     "app_inbox.category",
	ImageURL:     "app_inbox.image_url",
	LinkURL:      "app_inbox.link_url",
	CreatedAt:    "app_inbox.created_at",
	UpdatedAt:    "app_inbox.updated_at",
	Read:         "app_inbox.read",
	UserID:       "app_inbox.user_id",
	Claimed:      "app_inbox.claimed",
	ClamedAt:     "app_inbox.clamed_at",
	RewardID:     "app_inbox.reward_id",
	Clear:        "app_inbox.clear",
	GameWeekIDID: "app_inbox.game_week_id_id",
	MatchIDID:    "app_inbox.match_id_id",
	GameID:       "app_inbox.game_id",
}

// Generated where

type whereHelpertime_Time struct{ field string }

func (w whereHelpertime_Time) EQ(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.EQ, x)
}
func (w whereHelpertime_Time) NEQ(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.NEQ, x)
}
func (w whereHelpertime_Time) LT(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertime_Time) LTE(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertime_Time) GT(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertime_Time) GTE(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelperbool struct{ field string }

func (w whereHelperbool) EQ(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperbool) NEQ(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperbool) LT(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperbool) LTE(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperbool) GT(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperbool) GTE(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }

type whereHelpernull_Time struct{ field string }

func (w whereHelpernull_Time) EQ(x null.Time) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Time) NEQ(x null.Time) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Time) LT(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Time) LTE(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Time) GT(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Time) GTE(x null.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpernull_Time) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Time) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

var AppInboxWhere = struct {
	ID           whereHelperstring
	Title        whereHelperstring
	Description  whereHelperstring
	Status       whereHelperstring
	Priority     whereHelperstring
	Category     whereHelperstring
	ImageURL     whereHelpernull_String
	LinkURL      whereHelpernull_String
	CreatedAt    whereHelpertime_Time
	UpdatedAt    whereHelpertime_Time
	Read         whereHelperbool
	UserID       whereHelpernull_String
	Claimed      whereHelperbool
	ClamedAt     whereHelpernull_Time
	RewardID     whereHelpernull_String
	Clear        whereHelperbool
	GameWeekIDID whereHelpernull_String
	MatchIDID    whereHelpernull_String
	GameID       whereHelpernull_String
}{
	ID:           whereHelperstring{field: "\"app_inbox\".\"id\""},
	Title:        whereHelperstring{field: "\"app_inbox\".\"title\""},
	Description:  whereHelperstring{field: "\"app_inbox\".\"description\""},
	Status:       whereHelperstring{field: "\"app_inbox\".\"status\""},
	Priority:     whereHelperstring{field: "\"app_inbox\".\"priority\""},
	Category:     whereHelperstring{field: "\"app_inbox\".\"category\""},
	ImageURL:     whereHelpernull_String{field: "\"app_inbox\".\"image_url\""},
	LinkURL:      whereHelpernull_String{field: "\"app_inbox\".\"link_url\""},
	CreatedAt:    whereHelpertime_Time{field: "\"app_inbox\".\"created_at\""},
	UpdatedAt:    whereHelpertime_Time{field: "\"app_inbox\".\"updated_at\""},
	Read:         whereHelperbool{field: "\"app_inbox\".\"read\""},
	UserID:       whereHelpernull_String{field: "\"app_inbox\".\"user_id\""},
	Claimed:      whereHelperbool{field: "\"app_inbox\".\"claimed\""},
	ClamedAt:     whereHelpernull_Time{field: "\"app_inbox\".\"clamed_at\""},
	RewardID:     whereHelpernull_String{field: "\"app_inbox\".\"reward_id\""},
	Clear:        whereHelperbool{field: "\"app_inbox\".\"clear\""},
	GameWeekIDID: whereHelpernull_String{field: "\"app_inbox\".\"game_week_id_id\""},
	MatchIDID:    whereHelpernull_String{field: "\"app_inbox\".\"match_id_id\""},
	GameID:       whereHelpernull_String{field: "\"app_inbox\".\"game_id\""},
}

// AppInboxRels is where relationship names are stored.
var AppInboxRels = struct {
	Game       string
	GameWeekID string
	MatchID    string
	Reward     string
	User       string
}{
	Game:       "Game",
	GameWeekID: "GameWeekID",
	MatchID:    "MatchID",
	Reward:     "Reward",
	User:       "User",
}

// appInboxR is where relationships are stored.
type appInboxR struct {
	Game       *Game     `boil:"Game" json:"Game" toml:"Game" yaml:"Game"`
	GameWeekID *GameWeek `boil:"GameWeekID" json:"GameWeekID" toml:"GameWeekID" yaml:"GameWeekID"`
	MatchID    *Match    `boil:"MatchID" json:"MatchID" toml:"MatchID" yaml:"MatchID"`
	Reward     *Reward   `boil:"Reward" json:"Reward" toml:"Reward" yaml:"Reward"`
	User       *User     `boil:"User" json:"User" toml:"User" yaml:"User"`
}

// NewStruct creates a new relationship struct
func (*appInboxR) NewStruct() *appInboxR {
	return &appInboxR{}
}

func (r *appInboxR) GetGame() *Game {
	if r == nil {
		return nil
	}
	return r.Game
}

func (r *appInboxR) GetGameWeekID() *GameWeek {
	if r == nil {
		return nil
	}
	return r.GameWeekID
}

func (r *appInboxR) GetMatchID() *Match {
	if r == nil {
		return nil
	}
	return r.MatchID
}

func (r *appInboxR) GetReward() *Reward {
	if r == nil {
		return nil
	}
	return r.Reward
}

func (r *appInboxR) GetUser() *User {
	if r == nil {
		return nil
	}
	return r.User
}

// appInboxL is where Load methods for each relationship are stored.
type appInboxL struct{}

var (
	appInboxAllColumns            = []string{"id", "title", "description", "status", "priority", "category", "image_url", "link_url", "created_at", "updated_at", "read", "user_id", "claimed", "clamed_at", "reward_id", "clear", "game_week_id_id", "match_id_id", "game_id"}
	appInboxColumnsWithoutDefault = []string{"id", "title", "description", "status", "priority", "category", "created_at", "updated_at", "read", "claimed", "clear"}
	appInboxColumnsWithDefault    = []string{"image_url", "link_url", "user_id", "clamed_at", "reward_id", "game_week_id_id", "match_id_id", "game_id"}
	appInboxPrimaryKeyColumns     = []string{"id"}
	appInboxGeneratedColumns      = []string{}
)

type (
	// AppInboxSlice is an alias for a slice of pointers to AppInbox.
	// This should almost always be used instead of []AppInbox.
	AppInboxSlice []*AppInbox

	appInboxQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	appInboxType                 = reflect.TypeOf(&AppInbox{})
	appInboxMapping              = queries.MakeStructMapping(appInboxType)
	appInboxPrimaryKeyMapping, _ = queries.BindMapping(appInboxType, appInboxMapping, appInboxPrimaryKeyColumns)
	appInboxInsertCacheMut       sync.RWMutex
	appInboxInsertCache          = make(map[string]insertCache)
	appInboxUpdateCacheMut       sync.RWMutex
	appInboxUpdateCache          = make(map[string]updateCache)
	appInboxUpsertCacheMut       sync.RWMutex
	appInboxUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// One returns a single appInbox record from the query.
func (q appInboxQuery) One(exec boil.Executor) (*AppInbox, error) {
	o := &AppInbox{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(nil, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "schema: failed to execute a one query for app_inbox")
	}

	return o, nil
}

// All returns all AppInbox records from the query.
func (q appInboxQuery) All(exec boil.Executor) (AppInboxSlice, error) {
	var o []*AppInbox

	err := q.Bind(nil, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "schema: failed to assign all query results to AppInbox slice")
	}

	return o, nil
}

// Count returns the count of all AppInbox records in the query.
func (q appInboxQuery) Count(exec boil.Executor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "schema: failed to count app_inbox rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q appInboxQuery) Exists(exec boil.Executor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "schema: failed to check if app_inbox exists")
	}

	return count > 0, nil
}

// Game pointed to by the foreign key.
func (o *AppInbox) Game(mods ...qm.QueryMod) gameQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.GameID),
	}

	queryMods = append(queryMods, mods...)

	return Games(queryMods...)
}

// GameWeekID pointed to by the foreign key.
func (o *AppInbox) GameWeekID(mods ...qm.QueryMod) gameWeekQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.GameWeekIDID),
	}

	queryMods = append(queryMods, mods...)

	return GameWeeks(queryMods...)
}

// MatchID pointed to by the foreign key.
func (o *AppInbox) MatchID(mods ...qm.QueryMod) matchQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.MatchIDID),
	}

	queryMods = append(queryMods, mods...)

	return Matches(queryMods...)
}

// Reward pointed to by the foreign key.
func (o *AppInbox) Reward(mods ...qm.QueryMod) rewardQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.RewardID),
	}

	queryMods = append(queryMods, mods...)

	return Rewards(queryMods...)
}

// User pointed to by the foreign key.
func (o *AppInbox) User(mods ...qm.QueryMod) userQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.UserID),
	}

	queryMods = append(queryMods, mods...)

	return Users(queryMods...)
}

// LoadGame allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (appInboxL) LoadGame(e boil.Executor, singular bool, maybeAppInbox interface{}, mods queries.Applicator) error {
	var slice []*AppInbox
	var object *AppInbox

	if singular {
		var ok bool
		object, ok = maybeAppInbox.(*AppInbox)
		if !ok {
			object = new(AppInbox)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeAppInbox)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeAppInbox))
			}
		}
	} else {
		s, ok := maybeAppInbox.(*[]*AppInbox)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeAppInbox)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeAppInbox))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &appInboxR{}
		}
		if !queries.IsNil(object.GameID) {
			args[object.GameID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &appInboxR{}
			}

			if !queries.IsNil(obj.GameID) {
				args[obj.GameID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`games`),
		qm.WhereIn(`games.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Game")
	}

	var resultSlice []*Game
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Game")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for games")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for games")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Game = foreign
		if foreign.R == nil {
			foreign.R = &gameR{}
		}
		foreign.R.AppInboxes = append(foreign.R.AppInboxes, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.GameID, foreign.ID) {
				local.R.Game = foreign
				if foreign.R == nil {
					foreign.R = &gameR{}
				}
				foreign.R.AppInboxes = append(foreign.R.AppInboxes, local)
				break
			}
		}
	}

	return nil
}

// LoadGameWeekID allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (appInboxL) LoadGameWeekID(e boil.Executor, singular bool, maybeAppInbox interface{}, mods queries.Applicator) error {
	var slice []*AppInbox
	var object *AppInbox

	if singular {
		var ok bool
		object, ok = maybeAppInbox.(*AppInbox)
		if !ok {
			object = new(AppInbox)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeAppInbox)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeAppInbox))
			}
		}
	} else {
		s, ok := maybeAppInbox.(*[]*AppInbox)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeAppInbox)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeAppInbox))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &appInboxR{}
		}
		if !queries.IsNil(object.GameWeekIDID) {
			args[object.GameWeekIDID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &appInboxR{}
			}

			if !queries.IsNil(obj.GameWeekIDID) {
				args[obj.GameWeekIDID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`game_weeks`),
		qm.WhereIn(`game_weeks.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load GameWeek")
	}

	var resultSlice []*GameWeek
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice GameWeek")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for game_weeks")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for game_weeks")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.GameWeekID = foreign
		if foreign.R == nil {
			foreign.R = &gameWeekR{}
		}
		foreign.R.GameWeekIDAppInboxes = append(foreign.R.GameWeekIDAppInboxes, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.GameWeekIDID, foreign.ID) {
				local.R.GameWeekID = foreign
				if foreign.R == nil {
					foreign.R = &gameWeekR{}
				}
				foreign.R.GameWeekIDAppInboxes = append(foreign.R.GameWeekIDAppInboxes, local)
				break
			}
		}
	}

	return nil
}

// LoadMatchID allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (appInboxL) LoadMatchID(e boil.Executor, singular bool, maybeAppInbox interface{}, mods queries.Applicator) error {
	var slice []*AppInbox
	var object *AppInbox

	if singular {
		var ok bool
		object, ok = maybeAppInbox.(*AppInbox)
		if !ok {
			object = new(AppInbox)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeAppInbox)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeAppInbox))
			}
		}
	} else {
		s, ok := maybeAppInbox.(*[]*AppInbox)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeAppInbox)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeAppInbox))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &appInboxR{}
		}
		if !queries.IsNil(object.MatchIDID) {
			args[object.MatchIDID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &appInboxR{}
			}

			if !queries.IsNil(obj.MatchIDID) {
				args[obj.MatchIDID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`matches`),
		qm.WhereIn(`matches.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Match")
	}

	var resultSlice []*Match
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Match")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for matches")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for matches")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.MatchID = foreign
		if foreign.R == nil {
			foreign.R = &matchR{}
		}
		foreign.R.MatchIDAppInboxes = append(foreign.R.MatchIDAppInboxes, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.MatchIDID, foreign.ID) {
				local.R.MatchID = foreign
				if foreign.R == nil {
					foreign.R = &matchR{}
				}
				foreign.R.MatchIDAppInboxes = append(foreign.R.MatchIDAppInboxes, local)
				break
			}
		}
	}

	return nil
}

// LoadReward allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (appInboxL) LoadReward(e boil.Executor, singular bool, maybeAppInbox interface{}, mods queries.Applicator) error {
	var slice []*AppInbox
	var object *AppInbox

	if singular {
		var ok bool
		object, ok = maybeAppInbox.(*AppInbox)
		if !ok {
			object = new(AppInbox)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeAppInbox)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeAppInbox))
			}
		}
	} else {
		s, ok := maybeAppInbox.(*[]*AppInbox)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeAppInbox)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeAppInbox))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &appInboxR{}
		}
		if !queries.IsNil(object.RewardID) {
			args[object.RewardID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &appInboxR{}
			}

			if !queries.IsNil(obj.RewardID) {
				args[obj.RewardID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`rewards`),
		qm.WhereIn(`rewards.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Reward")
	}

	var resultSlice []*Reward
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Reward")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for rewards")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for rewards")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Reward = foreign
		if foreign.R == nil {
			foreign.R = &rewardR{}
		}
		foreign.R.AppInboxes = append(foreign.R.AppInboxes, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.RewardID, foreign.ID) {
				local.R.Reward = foreign
				if foreign.R == nil {
					foreign.R = &rewardR{}
				}
				foreign.R.AppInboxes = append(foreign.R.AppInboxes, local)
				break
			}
		}
	}

	return nil
}

// LoadUser allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (appInboxL) LoadUser(e boil.Executor, singular bool, maybeAppInbox interface{}, mods queries.Applicator) error {
	var slice []*AppInbox
	var object *AppInbox

	if singular {
		var ok bool
		object, ok = maybeAppInbox.(*AppInbox)
		if !ok {
			object = new(AppInbox)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeAppInbox)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeAppInbox))
			}
		}
	} else {
		s, ok := maybeAppInbox.(*[]*AppInbox)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeAppInbox)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeAppInbox))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &appInboxR{}
		}
		if !queries.IsNil(object.UserID) {
			args[object.UserID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &appInboxR{}
			}

			if !queries.IsNil(obj.UserID) {
				args[obj.UserID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`users`),
		qm.WhereIn(`users.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load User")
	}

	var resultSlice []*User
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice User")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for users")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for users")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.User = foreign
		if foreign.R == nil {
			foreign.R = &userR{}
		}
		foreign.R.AppInboxes = append(foreign.R.AppInboxes, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.UserID, foreign.ID) {
				local.R.User = foreign
				if foreign.R == nil {
					foreign.R = &userR{}
				}
				foreign.R.AppInboxes = append(foreign.R.AppInboxes, local)
				break
			}
		}
	}

	return nil
}

// SetGame of the appInbox to the related item.
// Sets o.R.Game to related.
// Adds o to related.R.AppInboxes.
func (o *AppInbox) SetGame(exec boil.Executor, insert bool, related *Game) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"app_inbox\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"game_id"}),
		strmangle.WhereClause("\"", "\"", 2, appInboxPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.GameID, related.ID)
	if o.R == nil {
		o.R = &appInboxR{
			Game: related,
		}
	} else {
		o.R.Game = related
	}

	if related.R == nil {
		related.R = &gameR{
			AppInboxes: AppInboxSlice{o},
		}
	} else {
		related.R.AppInboxes = append(related.R.AppInboxes, o)
	}

	return nil
}

// RemoveGame relationship.
// Sets o.R.Game to nil.
// Removes o from all passed in related items' relationships struct.
func (o *AppInbox) RemoveGame(exec boil.Executor, related *Game) error {
	var err error

	queries.SetScanner(&o.GameID, nil)
	if _, err = o.Update(exec, boil.Whitelist("game_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Game = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.AppInboxes {
		if queries.Equal(o.GameID, ri.GameID) {
			continue
		}

		ln := len(related.R.AppInboxes)
		if ln > 1 && i < ln-1 {
			related.R.AppInboxes[i] = related.R.AppInboxes[ln-1]
		}
		related.R.AppInboxes = related.R.AppInboxes[:ln-1]
		break
	}
	return nil
}

// SetGameWeekID of the appInbox to the related item.
// Sets o.R.GameWeekID to related.
// Adds o to related.R.GameWeekIDAppInboxes.
func (o *AppInbox) SetGameWeekID(exec boil.Executor, insert bool, related *GameWeek) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"app_inbox\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"game_week_id_id"}),
		strmangle.WhereClause("\"", "\"", 2, appInboxPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.GameWeekIDID, related.ID)
	if o.R == nil {
		o.R = &appInboxR{
			GameWeekID: related,
		}
	} else {
		o.R.GameWeekID = related
	}

	if related.R == nil {
		related.R = &gameWeekR{
			GameWeekIDAppInboxes: AppInboxSlice{o},
		}
	} else {
		related.R.GameWeekIDAppInboxes = append(related.R.GameWeekIDAppInboxes, o)
	}

	return nil
}

// RemoveGameWeekID relationship.
// Sets o.R.GameWeekID to nil.
// Removes o from all passed in related items' relationships struct.
func (o *AppInbox) RemoveGameWeekID(exec boil.Executor, related *GameWeek) error {
	var err error

	queries.SetScanner(&o.GameWeekIDID, nil)
	if _, err = o.Update(exec, boil.Whitelist("game_week_id_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.GameWeekID = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.GameWeekIDAppInboxes {
		if queries.Equal(o.GameWeekIDID, ri.GameWeekIDID) {
			continue
		}

		ln := len(related.R.GameWeekIDAppInboxes)
		if ln > 1 && i < ln-1 {
			related.R.GameWeekIDAppInboxes[i] = related.R.GameWeekIDAppInboxes[ln-1]
		}
		related.R.GameWeekIDAppInboxes = related.R.GameWeekIDAppInboxes[:ln-1]
		break
	}
	return nil
}

// SetMatchID of the appInbox to the related item.
// Sets o.R.MatchID to related.
// Adds o to related.R.MatchIDAppInboxes.
func (o *AppInbox) SetMatchID(exec boil.Executor, insert bool, related *Match) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"app_inbox\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"match_id_id"}),
		strmangle.WhereClause("\"", "\"", 2, appInboxPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.MatchIDID, related.ID)
	if o.R == nil {
		o.R = &appInboxR{
			MatchID: related,
		}
	} else {
		o.R.MatchID = related
	}

	if related.R == nil {
		related.R = &matchR{
			MatchIDAppInboxes: AppInboxSlice{o},
		}
	} else {
		related.R.MatchIDAppInboxes = append(related.R.MatchIDAppInboxes, o)
	}

	return nil
}

// RemoveMatchID relationship.
// Sets o.R.MatchID to nil.
// Removes o from all passed in related items' relationships struct.
func (o *AppInbox) RemoveMatchID(exec boil.Executor, related *Match) error {
	var err error

	queries.SetScanner(&o.MatchIDID, nil)
	if _, err = o.Update(exec, boil.Whitelist("match_id_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.MatchID = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.MatchIDAppInboxes {
		if queries.Equal(o.MatchIDID, ri.MatchIDID) {
			continue
		}

		ln := len(related.R.MatchIDAppInboxes)
		if ln > 1 && i < ln-1 {
			related.R.MatchIDAppInboxes[i] = related.R.MatchIDAppInboxes[ln-1]
		}
		related.R.MatchIDAppInboxes = related.R.MatchIDAppInboxes[:ln-1]
		break
	}
	return nil
}

// SetReward of the appInbox to the related item.
// Sets o.R.Reward to related.
// Adds o to related.R.AppInboxes.
func (o *AppInbox) SetReward(exec boil.Executor, insert bool, related *Reward) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"app_inbox\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"reward_id"}),
		strmangle.WhereClause("\"", "\"", 2, appInboxPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.RewardID, related.ID)
	if o.R == nil {
		o.R = &appInboxR{
			Reward: related,
		}
	} else {
		o.R.Reward = related
	}

	if related.R == nil {
		related.R = &rewardR{
			AppInboxes: AppInboxSlice{o},
		}
	} else {
		related.R.AppInboxes = append(related.R.AppInboxes, o)
	}

	return nil
}

// RemoveReward relationship.
// Sets o.R.Reward to nil.
// Removes o from all passed in related items' relationships struct.
func (o *AppInbox) RemoveReward(exec boil.Executor, related *Reward) error {
	var err error

	queries.SetScanner(&o.RewardID, nil)
	if _, err = o.Update(exec, boil.Whitelist("reward_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Reward = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.AppInboxes {
		if queries.Equal(o.RewardID, ri.RewardID) {
			continue
		}

		ln := len(related.R.AppInboxes)
		if ln > 1 && i < ln-1 {
			related.R.AppInboxes[i] = related.R.AppInboxes[ln-1]
		}
		related.R.AppInboxes = related.R.AppInboxes[:ln-1]
		break
	}
	return nil
}

// SetUser of the appInbox to the related item.
// Sets o.R.User to related.
// Adds o to related.R.AppInboxes.
func (o *AppInbox) SetUser(exec boil.Executor, insert bool, related *User) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"app_inbox\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"user_id"}),
		strmangle.WhereClause("\"", "\"", 2, appInboxPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.UserID, related.ID)
	if o.R == nil {
		o.R = &appInboxR{
			User: related,
		}
	} else {
		o.R.User = related
	}

	if related.R == nil {
		related.R = &userR{
			AppInboxes: AppInboxSlice{o},
		}
	} else {
		related.R.AppInboxes = append(related.R.AppInboxes, o)
	}

	return nil
}

// RemoveUser relationship.
// Sets o.R.User to nil.
// Removes o from all passed in related items' relationships struct.
func (o *AppInbox) RemoveUser(exec boil.Executor, related *User) error {
	var err error

	queries.SetScanner(&o.UserID, nil)
	if _, err = o.Update(exec, boil.Whitelist("user_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.User = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.AppInboxes {
		if queries.Equal(o.UserID, ri.UserID) {
			continue
		}

		ln := len(related.R.AppInboxes)
		if ln > 1 && i < ln-1 {
			related.R.AppInboxes[i] = related.R.AppInboxes[ln-1]
		}
		related.R.AppInboxes = related.R.AppInboxes[:ln-1]
		break
	}
	return nil
}

// AppInboxes retrieves all the records using an executor.
func AppInboxes(mods ...qm.QueryMod) appInboxQuery {
	mods = append(mods, qm.From("\"app_inbox\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"app_inbox\".*"})
	}

	return appInboxQuery{q}
}

// FindAppInbox retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindAppInbox(exec boil.Executor, iD string, selectCols ...string) (*AppInbox, error) {
	appInboxObj := &AppInbox{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"app_inbox\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(nil, exec, appInboxObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "schema: unable to select from app_inbox")
	}

	return appInboxObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *AppInbox) Insert(exec boil.Executor, columns boil.Columns) error {
	if o == nil {
		return errors.New("schema: no app_inbox provided for insertion")
	}

	var err error
	currTime := time.Now().In(boil.GetLocation())

	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}
	if o.UpdatedAt.IsZero() {
		o.UpdatedAt = currTime
	}

	nzDefaults := queries.NonZeroDefaultSet(appInboxColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	appInboxInsertCacheMut.RLock()
	cache, cached := appInboxInsertCache[key]
	appInboxInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			appInboxAllColumns,
			appInboxColumnsWithDefault,
			appInboxColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(appInboxType, appInboxMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(appInboxType, appInboxMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"app_inbox\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"app_inbox\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "schema: unable to insert into app_inbox")
	}

	if !cached {
		appInboxInsertCacheMut.Lock()
		appInboxInsertCache[key] = cache
		appInboxInsertCacheMut.Unlock()
	}

	return nil
}

// Update uses an executor to update the AppInbox.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *AppInbox) Update(exec boil.Executor, columns boil.Columns) (int64, error) {
	currTime := time.Now().In(boil.GetLocation())

	o.UpdatedAt = currTime

	var err error
	key := makeCacheKey(columns, nil)
	appInboxUpdateCacheMut.RLock()
	cache, cached := appInboxUpdateCache[key]
	appInboxUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			appInboxAllColumns,
			appInboxPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("schema: unable to update app_inbox, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"app_inbox\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, appInboxPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(appInboxType, appInboxMapping, append(wl, appInboxPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	var result sql.Result
	result, err = exec.Exec(cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to update app_inbox row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "schema: failed to get rows affected by update for app_inbox")
	}

	if !cached {
		appInboxUpdateCacheMut.Lock()
		appInboxUpdateCache[key] = cache
		appInboxUpdateCacheMut.Unlock()
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values.
func (q appInboxQuery) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to update all for app_inbox")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to retrieve rows affected for app_inbox")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o AppInboxSlice) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("schema: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), appInboxPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"app_inbox\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, appInboxPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to update all in appInbox slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to retrieve rows affected all in update all appInbox")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *AppInbox) Upsert(exec boil.Executor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("schema: no app_inbox provided for upsert")
	}
	currTime := time.Now().In(boil.GetLocation())

	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}
	o.UpdatedAt = currTime

	nzDefaults := queries.NonZeroDefaultSet(appInboxColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	appInboxUpsertCacheMut.RLock()
	cache, cached := appInboxUpsertCache[key]
	appInboxUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			appInboxAllColumns,
			appInboxColumnsWithDefault,
			appInboxColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			appInboxAllColumns,
			appInboxPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("schema: unable to upsert app_inbox, could not build update column list")
		}

		ret := strmangle.SetComplement(appInboxAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(appInboxPrimaryKeyColumns) == 0 {
				return errors.New("schema: unable to upsert app_inbox, could not build conflict column list")
			}

			conflict = make([]string, len(appInboxPrimaryKeyColumns))
			copy(conflict, appInboxPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"app_inbox\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(appInboxType, appInboxMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(appInboxType, appInboxMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "schema: unable to upsert app_inbox")
	}

	if !cached {
		appInboxUpsertCacheMut.Lock()
		appInboxUpsertCache[key] = cache
		appInboxUpsertCacheMut.Unlock()
	}

	return nil
}

// Delete deletes a single AppInbox record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *AppInbox) Delete(exec boil.Executor) (int64, error) {
	if o == nil {
		return 0, errors.New("schema: no AppInbox provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), appInboxPrimaryKeyMapping)
	sql := "DELETE FROM \"app_inbox\" WHERE \"id\"=$1"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to delete from app_inbox")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "schema: failed to get rows affected by delete for app_inbox")
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q appInboxQuery) DeleteAll(exec boil.Executor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("schema: no appInboxQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to delete all from app_inbox")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "schema: failed to get rows affected by deleteall for app_inbox")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o AppInboxSlice) DeleteAll(exec boil.Executor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), appInboxPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"app_inbox\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, appInboxPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to delete all from appInbox slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "schema: failed to get rows affected by deleteall for app_inbox")
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *AppInbox) Reload(exec boil.Executor) error {
	ret, err := FindAppInbox(exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *AppInboxSlice) ReloadAll(exec boil.Executor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := AppInboxSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), appInboxPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"app_inbox\".* FROM \"app_inbox\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, appInboxPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(nil, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "schema: unable to reload all in AppInboxSlice")
	}

	*o = slice

	return nil
}

// AppInboxExists checks if the AppInbox row exists.
func AppInboxExists(exec boil.Executor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"app_inbox\" where \"id\"=$1 limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}
	row := exec.QueryRow(sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "schema: unable to check if app_inbox exists")
	}

	return exists, nil
}

// Exists checks if the AppInbox row exists.
func (o *AppInbox) Exists(exec boil.Executor) (bool, error) {
	return AppInboxExists(exec, o.ID)
}
