// Code generated by SQLBoiler 4.16.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package schema

import (
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// DjangoCeleryBeatPeriodictask is an object representing the database table.
type DjangoCeleryBeatPeriodictask struct {
	ID            int         `boil:"id" json:"id" toml:"id" yaml:"id"`
	Name          string      `boil:"name" json:"name" toml:"name" yaml:"name"`
	Task          string      `boil:"task" json:"task" toml:"task" yaml:"task"`
	Args          string      `boil:"args" json:"args" toml:"args" yaml:"args"`
	Kwargs        string      `boil:"kwargs" json:"kwargs" toml:"kwargs" yaml:"kwargs"`
	Queue         null.String `boil:"queue" json:"queue,omitempty" toml:"queue" yaml:"queue,omitempty"`
	Exchange      null.String `boil:"exchange" json:"exchange,omitempty" toml:"exchange" yaml:"exchange,omitempty"`
	RoutingKey    null.String `boil:"routing_key" json:"routing_key,omitempty" toml:"routing_key" yaml:"routing_key,omitempty"`
	Expires       null.Time   `boil:"expires" json:"expires,omitempty" toml:"expires" yaml:"expires,omitempty"`
	Enabled       bool        `boil:"enabled" json:"enabled" toml:"enabled" yaml:"enabled"`
	LastRunAt     null.Time   `boil:"last_run_at" json:"last_run_at,omitempty" toml:"last_run_at" yaml:"last_run_at,omitempty"`
	TotalRunCount int         `boil:"total_run_count" json:"total_run_count" toml:"total_run_count" yaml:"total_run_count"`
	DateChanged   time.Time   `boil:"date_changed" json:"date_changed" toml:"date_changed" yaml:"date_changed"`
	Description   string      `boil:"description" json:"description" toml:"description" yaml:"description"`
	CrontabID     null.Int    `boil:"crontab_id" json:"crontab_id,omitempty" toml:"crontab_id" yaml:"crontab_id,omitempty"`
	IntervalID    null.Int    `boil:"interval_id" json:"interval_id,omitempty" toml:"interval_id" yaml:"interval_id,omitempty"`
	SolarID       null.Int    `boil:"solar_id" json:"solar_id,omitempty" toml:"solar_id" yaml:"solar_id,omitempty"`
	OneOff        bool        `boil:"one_off" json:"one_off" toml:"one_off" yaml:"one_off"`
	StartTime     null.Time   `boil:"start_time" json:"start_time,omitempty" toml:"start_time" yaml:"start_time,omitempty"`
	Priority      null.Int    `boil:"priority" json:"priority,omitempty" toml:"priority" yaml:"priority,omitempty"`
	Headers       string      `boil:"headers" json:"headers" toml:"headers" yaml:"headers"`
	ClockedID     null.Int    `boil:"clocked_id" json:"clocked_id,omitempty" toml:"clocked_id" yaml:"clocked_id,omitempty"`
	ExpireSeconds null.Int    `boil:"expire_seconds" json:"expire_seconds,omitempty" toml:"expire_seconds" yaml:"expire_seconds,omitempty"`

	R *djangoCeleryBeatPeriodictaskR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L djangoCeleryBeatPeriodictaskL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var DjangoCeleryBeatPeriodictaskColumns = struct {
	ID            string
	Name          string
	Task          string
	Args          string
	Kwargs        string
	Queue         string
	Exchange      string
	RoutingKey    string
	Expires       string
	Enabled       string
	LastRunAt     string
	TotalRunCount string
	DateChanged   string
	Description   string
	CrontabID     string
	IntervalID    string
	SolarID       string
	OneOff        string
	StartTime     string
	Priority      string
	Headers       string
	ClockedID     string
	ExpireSeconds string
}{
	ID:            "id",
	Name:          "name",
	Task:          "task",
	Args:          "args",
	Kwargs:        "kwargs",
	Queue:         "queue",
	Exchange:      "exchange",
	RoutingKey:    "routing_key",
	Expires:       "expires",
	Enabled:       "enabled",
	LastRunAt:     "last_run_at",
	TotalRunCount: "total_run_count",
	DateChanged:   "date_changed",
	Description:   "description",
	CrontabID:     "crontab_id",
	IntervalID:    "interval_id",
	SolarID:       "solar_id",
	OneOff:        "one_off",
	StartTime:     "start_time",
	Priority:      "priority",
	Headers:       "headers",
	ClockedID:     "clocked_id",
	ExpireSeconds: "expire_seconds",
}

var DjangoCeleryBeatPeriodictaskTableColumns = struct {
	ID            string
	Name          string
	Task          string
	Args          string
	Kwargs        string
	Queue         string
	Exchange      string
	RoutingKey    string
	Expires       string
	Enabled       string
	LastRunAt     string
	TotalRunCount string
	DateChanged   string
	Description   string
	CrontabID     string
	IntervalID    string
	SolarID       string
	OneOff        string
	StartTime     string
	Priority      string
	Headers       string
	ClockedID     string
	ExpireSeconds string
}{
	ID:            "django_celery_beat_periodictask.id",
	Name:          "django_celery_beat_periodictask.name",
	Task:          "django_celery_beat_periodictask.task",
	Args:          "django_celery_beat_periodictask.args",
	Kwargs:        "django_celery_beat_periodictask.kwargs",
	Queue:         "django_celery_beat_periodictask.queue",
	Exchange:      "django_celery_beat_periodictask.exchange",
	RoutingKey:    "django_celery_beat_periodictask.routing_key",
	Expires:       "django_celery_beat_periodictask.expires",
	Enabled:       "django_celery_beat_periodictask.enabled",
	LastRunAt:     "django_celery_beat_periodictask.last_run_at",
	TotalRunCount: "django_celery_beat_periodictask.total_run_count",
	DateChanged:   "django_celery_beat_periodictask.date_changed",
	Description:   "django_celery_beat_periodictask.description",
	CrontabID:     "django_celery_beat_periodictask.crontab_id",
	IntervalID:    "django_celery_beat_periodictask.interval_id",
	SolarID:       "django_celery_beat_periodictask.solar_id",
	OneOff:        "django_celery_beat_periodictask.one_off",
	StartTime:     "django_celery_beat_periodictask.start_time",
	Priority:      "django_celery_beat_periodictask.priority",
	Headers:       "django_celery_beat_periodictask.headers",
	ClockedID:     "django_celery_beat_periodictask.clocked_id",
	ExpireSeconds: "django_celery_beat_periodictask.expire_seconds",
}

// Generated where

var DjangoCeleryBeatPeriodictaskWhere = struct {
	ID            whereHelperint
	Name          whereHelperstring
	Task          whereHelperstring
	Args          whereHelperstring
	Kwargs        whereHelperstring
	Queue         whereHelpernull_String
	Exchange      whereHelpernull_String
	RoutingKey    whereHelpernull_String
	Expires       whereHelpernull_Time
	Enabled       whereHelperbool
	LastRunAt     whereHelpernull_Time
	TotalRunCount whereHelperint
	DateChanged   whereHelpertime_Time
	Description   whereHelperstring
	CrontabID     whereHelpernull_Int
	IntervalID    whereHelpernull_Int
	SolarID       whereHelpernull_Int
	OneOff        whereHelperbool
	StartTime     whereHelpernull_Time
	Priority      whereHelpernull_Int
	Headers       whereHelperstring
	ClockedID     whereHelpernull_Int
	ExpireSeconds whereHelpernull_Int
}{
	ID:            whereHelperint{field: "\"django_celery_beat_periodictask\".\"id\""},
	Name:          whereHelperstring{field: "\"django_celery_beat_periodictask\".\"name\""},
	Task:          whereHelperstring{field: "\"django_celery_beat_periodictask\".\"task\""},
	Args:          whereHelperstring{field: "\"django_celery_beat_periodictask\".\"args\""},
	Kwargs:        whereHelperstring{field: "\"django_celery_beat_periodictask\".\"kwargs\""},
	Queue:         whereHelpernull_String{field: "\"django_celery_beat_periodictask\".\"queue\""},
	Exchange:      whereHelpernull_String{field: "\"django_celery_beat_periodictask\".\"exchange\""},
	RoutingKey:    whereHelpernull_String{field: "\"django_celery_beat_periodictask\".\"routing_key\""},
	Expires:       whereHelpernull_Time{field: "\"django_celery_beat_periodictask\".\"expires\""},
	Enabled:       whereHelperbool{field: "\"django_celery_beat_periodictask\".\"enabled\""},
	LastRunAt:     whereHelpernull_Time{field: "\"django_celery_beat_periodictask\".\"last_run_at\""},
	TotalRunCount: whereHelperint{field: "\"django_celery_beat_periodictask\".\"total_run_count\""},
	DateChanged:   whereHelpertime_Time{field: "\"django_celery_beat_periodictask\".\"date_changed\""},
	Description:   whereHelperstring{field: "\"django_celery_beat_periodictask\".\"description\""},
	CrontabID:     whereHelpernull_Int{field: "\"django_celery_beat_periodictask\".\"crontab_id\""},
	IntervalID:    whereHelpernull_Int{field: "\"django_celery_beat_periodictask\".\"interval_id\""},
	SolarID:       whereHelpernull_Int{field: "\"django_celery_beat_periodictask\".\"solar_id\""},
	OneOff:        whereHelperbool{field: "\"django_celery_beat_periodictask\".\"one_off\""},
	StartTime:     whereHelpernull_Time{field: "\"django_celery_beat_periodictask\".\"start_time\""},
	Priority:      whereHelpernull_Int{field: "\"django_celery_beat_periodictask\".\"priority\""},
	Headers:       whereHelperstring{field: "\"django_celery_beat_periodictask\".\"headers\""},
	ClockedID:     whereHelpernull_Int{field: "\"django_celery_beat_periodictask\".\"clocked_id\""},
	ExpireSeconds: whereHelpernull_Int{field: "\"django_celery_beat_periodictask\".\"expire_seconds\""},
}

// DjangoCeleryBeatPeriodictaskRels is where relationship names are stored.
var DjangoCeleryBeatPeriodictaskRels = struct {
	Clocked  string
	Crontab  string
	Interval string
	Solar    string
}{
	Clocked:  "Clocked",
	Crontab:  "Crontab",
	Interval: "Interval",
	Solar:    "Solar",
}

// djangoCeleryBeatPeriodictaskR is where relationships are stored.
type djangoCeleryBeatPeriodictaskR struct {
	Clocked  *DjangoCeleryBeatClockedschedule  `boil:"Clocked" json:"Clocked" toml:"Clocked" yaml:"Clocked"`
	Crontab  *DjangoCeleryBeatCrontabschedule  `boil:"Crontab" json:"Crontab" toml:"Crontab" yaml:"Crontab"`
	Interval *DjangoCeleryBeatIntervalschedule `boil:"Interval" json:"Interval" toml:"Interval" yaml:"Interval"`
	Solar    *DjangoCeleryBeatSolarschedule    `boil:"Solar" json:"Solar" toml:"Solar" yaml:"Solar"`
}

// NewStruct creates a new relationship struct
func (*djangoCeleryBeatPeriodictaskR) NewStruct() *djangoCeleryBeatPeriodictaskR {
	return &djangoCeleryBeatPeriodictaskR{}
}

func (r *djangoCeleryBeatPeriodictaskR) GetClocked() *DjangoCeleryBeatClockedschedule {
	if r == nil {
		return nil
	}
	return r.Clocked
}

func (r *djangoCeleryBeatPeriodictaskR) GetCrontab() *DjangoCeleryBeatCrontabschedule {
	if r == nil {
		return nil
	}
	return r.Crontab
}

func (r *djangoCeleryBeatPeriodictaskR) GetInterval() *DjangoCeleryBeatIntervalschedule {
	if r == nil {
		return nil
	}
	return r.Interval
}

func (r *djangoCeleryBeatPeriodictaskR) GetSolar() *DjangoCeleryBeatSolarschedule {
	if r == nil {
		return nil
	}
	return r.Solar
}

// djangoCeleryBeatPeriodictaskL is where Load methods for each relationship are stored.
type djangoCeleryBeatPeriodictaskL struct{}

var (
	djangoCeleryBeatPeriodictaskAllColumns            = []string{"id", "name", "task", "args", "kwargs", "queue", "exchange", "routing_key", "expires", "enabled", "last_run_at", "total_run_count", "date_changed", "description", "crontab_id", "interval_id", "solar_id", "one_off", "start_time", "priority", "headers", "clocked_id", "expire_seconds"}
	djangoCeleryBeatPeriodictaskColumnsWithoutDefault = []string{"name", "task", "args", "kwargs", "enabled", "total_run_count", "date_changed", "description", "one_off", "headers"}
	djangoCeleryBeatPeriodictaskColumnsWithDefault    = []string{"id", "queue", "exchange", "routing_key", "expires", "last_run_at", "crontab_id", "interval_id", "solar_id", "start_time", "priority", "clocked_id", "expire_seconds"}
	djangoCeleryBeatPeriodictaskPrimaryKeyColumns     = []string{"id"}
	djangoCeleryBeatPeriodictaskGeneratedColumns      = []string{}
)

type (
	// DjangoCeleryBeatPeriodictaskSlice is an alias for a slice of pointers to DjangoCeleryBeatPeriodictask.
	// This should almost always be used instead of []DjangoCeleryBeatPeriodictask.
	DjangoCeleryBeatPeriodictaskSlice []*DjangoCeleryBeatPeriodictask

	djangoCeleryBeatPeriodictaskQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	djangoCeleryBeatPeriodictaskType                 = reflect.TypeOf(&DjangoCeleryBeatPeriodictask{})
	djangoCeleryBeatPeriodictaskMapping              = queries.MakeStructMapping(djangoCeleryBeatPeriodictaskType)
	djangoCeleryBeatPeriodictaskPrimaryKeyMapping, _ = queries.BindMapping(djangoCeleryBeatPeriodictaskType, djangoCeleryBeatPeriodictaskMapping, djangoCeleryBeatPeriodictaskPrimaryKeyColumns)
	djangoCeleryBeatPeriodictaskInsertCacheMut       sync.RWMutex
	djangoCeleryBeatPeriodictaskInsertCache          = make(map[string]insertCache)
	djangoCeleryBeatPeriodictaskUpdateCacheMut       sync.RWMutex
	djangoCeleryBeatPeriodictaskUpdateCache          = make(map[string]updateCache)
	djangoCeleryBeatPeriodictaskUpsertCacheMut       sync.RWMutex
	djangoCeleryBeatPeriodictaskUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// One returns a single djangoCeleryBeatPeriodictask record from the query.
func (q djangoCeleryBeatPeriodictaskQuery) One(exec boil.Executor) (*DjangoCeleryBeatPeriodictask, error) {
	o := &DjangoCeleryBeatPeriodictask{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(nil, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "schema: failed to execute a one query for django_celery_beat_periodictask")
	}

	return o, nil
}

// All returns all DjangoCeleryBeatPeriodictask records from the query.
func (q djangoCeleryBeatPeriodictaskQuery) All(exec boil.Executor) (DjangoCeleryBeatPeriodictaskSlice, error) {
	var o []*DjangoCeleryBeatPeriodictask

	err := q.Bind(nil, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "schema: failed to assign all query results to DjangoCeleryBeatPeriodictask slice")
	}

	return o, nil
}

// Count returns the count of all DjangoCeleryBeatPeriodictask records in the query.
func (q djangoCeleryBeatPeriodictaskQuery) Count(exec boil.Executor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "schema: failed to count django_celery_beat_periodictask rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q djangoCeleryBeatPeriodictaskQuery) Exists(exec boil.Executor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "schema: failed to check if django_celery_beat_periodictask exists")
	}

	return count > 0, nil
}

// Clocked pointed to by the foreign key.
func (o *DjangoCeleryBeatPeriodictask) Clocked(mods ...qm.QueryMod) djangoCeleryBeatClockedscheduleQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.ClockedID),
	}

	queryMods = append(queryMods, mods...)

	return DjangoCeleryBeatClockedschedules(queryMods...)
}

// Crontab pointed to by the foreign key.
func (o *DjangoCeleryBeatPeriodictask) Crontab(mods ...qm.QueryMod) djangoCeleryBeatCrontabscheduleQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.CrontabID),
	}

	queryMods = append(queryMods, mods...)

	return DjangoCeleryBeatCrontabschedules(queryMods...)
}

// Interval pointed to by the foreign key.
func (o *DjangoCeleryBeatPeriodictask) Interval(mods ...qm.QueryMod) djangoCeleryBeatIntervalscheduleQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.IntervalID),
	}

	queryMods = append(queryMods, mods...)

	return DjangoCeleryBeatIntervalschedules(queryMods...)
}

// Solar pointed to by the foreign key.
func (o *DjangoCeleryBeatPeriodictask) Solar(mods ...qm.QueryMod) djangoCeleryBeatSolarscheduleQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.SolarID),
	}

	queryMods = append(queryMods, mods...)

	return DjangoCeleryBeatSolarschedules(queryMods...)
}

// LoadClocked allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (djangoCeleryBeatPeriodictaskL) LoadClocked(e boil.Executor, singular bool, maybeDjangoCeleryBeatPeriodictask interface{}, mods queries.Applicator) error {
	var slice []*DjangoCeleryBeatPeriodictask
	var object *DjangoCeleryBeatPeriodictask

	if singular {
		var ok bool
		object, ok = maybeDjangoCeleryBeatPeriodictask.(*DjangoCeleryBeatPeriodictask)
		if !ok {
			object = new(DjangoCeleryBeatPeriodictask)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDjangoCeleryBeatPeriodictask)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDjangoCeleryBeatPeriodictask))
			}
		}
	} else {
		s, ok := maybeDjangoCeleryBeatPeriodictask.(*[]*DjangoCeleryBeatPeriodictask)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDjangoCeleryBeatPeriodictask)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDjangoCeleryBeatPeriodictask))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &djangoCeleryBeatPeriodictaskR{}
		}
		if !queries.IsNil(object.ClockedID) {
			args[object.ClockedID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &djangoCeleryBeatPeriodictaskR{}
			}

			if !queries.IsNil(obj.ClockedID) {
				args[obj.ClockedID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`django_celery_beat_clockedschedule`),
		qm.WhereIn(`django_celery_beat_clockedschedule.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DjangoCeleryBeatClockedschedule")
	}

	var resultSlice []*DjangoCeleryBeatClockedschedule
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DjangoCeleryBeatClockedschedule")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for django_celery_beat_clockedschedule")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for django_celery_beat_clockedschedule")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Clocked = foreign
		if foreign.R == nil {
			foreign.R = &djangoCeleryBeatClockedscheduleR{}
		}
		foreign.R.ClockedDjangoCeleryBeatPeriodictasks = append(foreign.R.ClockedDjangoCeleryBeatPeriodictasks, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ClockedID, foreign.ID) {
				local.R.Clocked = foreign
				if foreign.R == nil {
					foreign.R = &djangoCeleryBeatClockedscheduleR{}
				}
				foreign.R.ClockedDjangoCeleryBeatPeriodictasks = append(foreign.R.ClockedDjangoCeleryBeatPeriodictasks, local)
				break
			}
		}
	}

	return nil
}

// LoadCrontab allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (djangoCeleryBeatPeriodictaskL) LoadCrontab(e boil.Executor, singular bool, maybeDjangoCeleryBeatPeriodictask interface{}, mods queries.Applicator) error {
	var slice []*DjangoCeleryBeatPeriodictask
	var object *DjangoCeleryBeatPeriodictask

	if singular {
		var ok bool
		object, ok = maybeDjangoCeleryBeatPeriodictask.(*DjangoCeleryBeatPeriodictask)
		if !ok {
			object = new(DjangoCeleryBeatPeriodictask)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDjangoCeleryBeatPeriodictask)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDjangoCeleryBeatPeriodictask))
			}
		}
	} else {
		s, ok := maybeDjangoCeleryBeatPeriodictask.(*[]*DjangoCeleryBeatPeriodictask)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDjangoCeleryBeatPeriodictask)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDjangoCeleryBeatPeriodictask))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &djangoCeleryBeatPeriodictaskR{}
		}
		if !queries.IsNil(object.CrontabID) {
			args[object.CrontabID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &djangoCeleryBeatPeriodictaskR{}
			}

			if !queries.IsNil(obj.CrontabID) {
				args[obj.CrontabID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`django_celery_beat_crontabschedule`),
		qm.WhereIn(`django_celery_beat_crontabschedule.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DjangoCeleryBeatCrontabschedule")
	}

	var resultSlice []*DjangoCeleryBeatCrontabschedule
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DjangoCeleryBeatCrontabschedule")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for django_celery_beat_crontabschedule")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for django_celery_beat_crontabschedule")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Crontab = foreign
		if foreign.R == nil {
			foreign.R = &djangoCeleryBeatCrontabscheduleR{}
		}
		foreign.R.CrontabDjangoCeleryBeatPeriodictasks = append(foreign.R.CrontabDjangoCeleryBeatPeriodictasks, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.CrontabID, foreign.ID) {
				local.R.Crontab = foreign
				if foreign.R == nil {
					foreign.R = &djangoCeleryBeatCrontabscheduleR{}
				}
				foreign.R.CrontabDjangoCeleryBeatPeriodictasks = append(foreign.R.CrontabDjangoCeleryBeatPeriodictasks, local)
				break
			}
		}
	}

	return nil
}

// LoadInterval allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (djangoCeleryBeatPeriodictaskL) LoadInterval(e boil.Executor, singular bool, maybeDjangoCeleryBeatPeriodictask interface{}, mods queries.Applicator) error {
	var slice []*DjangoCeleryBeatPeriodictask
	var object *DjangoCeleryBeatPeriodictask

	if singular {
		var ok bool
		object, ok = maybeDjangoCeleryBeatPeriodictask.(*DjangoCeleryBeatPeriodictask)
		if !ok {
			object = new(DjangoCeleryBeatPeriodictask)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDjangoCeleryBeatPeriodictask)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDjangoCeleryBeatPeriodictask))
			}
		}
	} else {
		s, ok := maybeDjangoCeleryBeatPeriodictask.(*[]*DjangoCeleryBeatPeriodictask)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDjangoCeleryBeatPeriodictask)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDjangoCeleryBeatPeriodictask))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &djangoCeleryBeatPeriodictaskR{}
		}
		if !queries.IsNil(object.IntervalID) {
			args[object.IntervalID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &djangoCeleryBeatPeriodictaskR{}
			}

			if !queries.IsNil(obj.IntervalID) {
				args[obj.IntervalID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`django_celery_beat_intervalschedule`),
		qm.WhereIn(`django_celery_beat_intervalschedule.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DjangoCeleryBeatIntervalschedule")
	}

	var resultSlice []*DjangoCeleryBeatIntervalschedule
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DjangoCeleryBeatIntervalschedule")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for django_celery_beat_intervalschedule")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for django_celery_beat_intervalschedule")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Interval = foreign
		if foreign.R == nil {
			foreign.R = &djangoCeleryBeatIntervalscheduleR{}
		}
		foreign.R.IntervalDjangoCeleryBeatPeriodictasks = append(foreign.R.IntervalDjangoCeleryBeatPeriodictasks, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.IntervalID, foreign.ID) {
				local.R.Interval = foreign
				if foreign.R == nil {
					foreign.R = &djangoCeleryBeatIntervalscheduleR{}
				}
				foreign.R.IntervalDjangoCeleryBeatPeriodictasks = append(foreign.R.IntervalDjangoCeleryBeatPeriodictasks, local)
				break
			}
		}
	}

	return nil
}

// LoadSolar allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (djangoCeleryBeatPeriodictaskL) LoadSolar(e boil.Executor, singular bool, maybeDjangoCeleryBeatPeriodictask interface{}, mods queries.Applicator) error {
	var slice []*DjangoCeleryBeatPeriodictask
	var object *DjangoCeleryBeatPeriodictask

	if singular {
		var ok bool
		object, ok = maybeDjangoCeleryBeatPeriodictask.(*DjangoCeleryBeatPeriodictask)
		if !ok {
			object = new(DjangoCeleryBeatPeriodictask)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDjangoCeleryBeatPeriodictask)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDjangoCeleryBeatPeriodictask))
			}
		}
	} else {
		s, ok := maybeDjangoCeleryBeatPeriodictask.(*[]*DjangoCeleryBeatPeriodictask)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDjangoCeleryBeatPeriodictask)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDjangoCeleryBeatPeriodictask))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &djangoCeleryBeatPeriodictaskR{}
		}
		if !queries.IsNil(object.SolarID) {
			args[object.SolarID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &djangoCeleryBeatPeriodictaskR{}
			}

			if !queries.IsNil(obj.SolarID) {
				args[obj.SolarID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`django_celery_beat_solarschedule`),
		qm.WhereIn(`django_celery_beat_solarschedule.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DjangoCeleryBeatSolarschedule")
	}

	var resultSlice []*DjangoCeleryBeatSolarschedule
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DjangoCeleryBeatSolarschedule")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for django_celery_beat_solarschedule")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for django_celery_beat_solarschedule")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Solar = foreign
		if foreign.R == nil {
			foreign.R = &djangoCeleryBeatSolarscheduleR{}
		}
		foreign.R.SolarDjangoCeleryBeatPeriodictasks = append(foreign.R.SolarDjangoCeleryBeatPeriodictasks, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.SolarID, foreign.ID) {
				local.R.Solar = foreign
				if foreign.R == nil {
					foreign.R = &djangoCeleryBeatSolarscheduleR{}
				}
				foreign.R.SolarDjangoCeleryBeatPeriodictasks = append(foreign.R.SolarDjangoCeleryBeatPeriodictasks, local)
				break
			}
		}
	}

	return nil
}

// SetClocked of the djangoCeleryBeatPeriodictask to the related item.
// Sets o.R.Clocked to related.
// Adds o to related.R.ClockedDjangoCeleryBeatPeriodictasks.
func (o *DjangoCeleryBeatPeriodictask) SetClocked(exec boil.Executor, insert bool, related *DjangoCeleryBeatClockedschedule) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"django_celery_beat_periodictask\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"clocked_id"}),
		strmangle.WhereClause("\"", "\"", 2, djangoCeleryBeatPeriodictaskPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.ClockedID, related.ID)
	if o.R == nil {
		o.R = &djangoCeleryBeatPeriodictaskR{
			Clocked: related,
		}
	} else {
		o.R.Clocked = related
	}

	if related.R == nil {
		related.R = &djangoCeleryBeatClockedscheduleR{
			ClockedDjangoCeleryBeatPeriodictasks: DjangoCeleryBeatPeriodictaskSlice{o},
		}
	} else {
		related.R.ClockedDjangoCeleryBeatPeriodictasks = append(related.R.ClockedDjangoCeleryBeatPeriodictasks, o)
	}

	return nil
}

// RemoveClocked relationship.
// Sets o.R.Clocked to nil.
// Removes o from all passed in related items' relationships struct.
func (o *DjangoCeleryBeatPeriodictask) RemoveClocked(exec boil.Executor, related *DjangoCeleryBeatClockedschedule) error {
	var err error

	queries.SetScanner(&o.ClockedID, nil)
	if _, err = o.Update(exec, boil.Whitelist("clocked_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Clocked = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.ClockedDjangoCeleryBeatPeriodictasks {
		if queries.Equal(o.ClockedID, ri.ClockedID) {
			continue
		}

		ln := len(related.R.ClockedDjangoCeleryBeatPeriodictasks)
		if ln > 1 && i < ln-1 {
			related.R.ClockedDjangoCeleryBeatPeriodictasks[i] = related.R.ClockedDjangoCeleryBeatPeriodictasks[ln-1]
		}
		related.R.ClockedDjangoCeleryBeatPeriodictasks = related.R.ClockedDjangoCeleryBeatPeriodictasks[:ln-1]
		break
	}
	return nil
}

// SetCrontab of the djangoCeleryBeatPeriodictask to the related item.
// Sets o.R.Crontab to related.
// Adds o to related.R.CrontabDjangoCeleryBeatPeriodictasks.
func (o *DjangoCeleryBeatPeriodictask) SetCrontab(exec boil.Executor, insert bool, related *DjangoCeleryBeatCrontabschedule) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"django_celery_beat_periodictask\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"crontab_id"}),
		strmangle.WhereClause("\"", "\"", 2, djangoCeleryBeatPeriodictaskPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.CrontabID, related.ID)
	if o.R == nil {
		o.R = &djangoCeleryBeatPeriodictaskR{
			Crontab: related,
		}
	} else {
		o.R.Crontab = related
	}

	if related.R == nil {
		related.R = &djangoCeleryBeatCrontabscheduleR{
			CrontabDjangoCeleryBeatPeriodictasks: DjangoCeleryBeatPeriodictaskSlice{o},
		}
	} else {
		related.R.CrontabDjangoCeleryBeatPeriodictasks = append(related.R.CrontabDjangoCeleryBeatPeriodictasks, o)
	}

	return nil
}

// RemoveCrontab relationship.
// Sets o.R.Crontab to nil.
// Removes o from all passed in related items' relationships struct.
func (o *DjangoCeleryBeatPeriodictask) RemoveCrontab(exec boil.Executor, related *DjangoCeleryBeatCrontabschedule) error {
	var err error

	queries.SetScanner(&o.CrontabID, nil)
	if _, err = o.Update(exec, boil.Whitelist("crontab_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Crontab = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.CrontabDjangoCeleryBeatPeriodictasks {
		if queries.Equal(o.CrontabID, ri.CrontabID) {
			continue
		}

		ln := len(related.R.CrontabDjangoCeleryBeatPeriodictasks)
		if ln > 1 && i < ln-1 {
			related.R.CrontabDjangoCeleryBeatPeriodictasks[i] = related.R.CrontabDjangoCeleryBeatPeriodictasks[ln-1]
		}
		related.R.CrontabDjangoCeleryBeatPeriodictasks = related.R.CrontabDjangoCeleryBeatPeriodictasks[:ln-1]
		break
	}
	return nil
}

// SetInterval of the djangoCeleryBeatPeriodictask to the related item.
// Sets o.R.Interval to related.
// Adds o to related.R.IntervalDjangoCeleryBeatPeriodictasks.
func (o *DjangoCeleryBeatPeriodictask) SetInterval(exec boil.Executor, insert bool, related *DjangoCeleryBeatIntervalschedule) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"django_celery_beat_periodictask\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"interval_id"}),
		strmangle.WhereClause("\"", "\"", 2, djangoCeleryBeatPeriodictaskPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.IntervalID, related.ID)
	if o.R == nil {
		o.R = &djangoCeleryBeatPeriodictaskR{
			Interval: related,
		}
	} else {
		o.R.Interval = related
	}

	if related.R == nil {
		related.R = &djangoCeleryBeatIntervalscheduleR{
			IntervalDjangoCeleryBeatPeriodictasks: DjangoCeleryBeatPeriodictaskSlice{o},
		}
	} else {
		related.R.IntervalDjangoCeleryBeatPeriodictasks = append(related.R.IntervalDjangoCeleryBeatPeriodictasks, o)
	}

	return nil
}

// RemoveInterval relationship.
// Sets o.R.Interval to nil.
// Removes o from all passed in related items' relationships struct.
func (o *DjangoCeleryBeatPeriodictask) RemoveInterval(exec boil.Executor, related *DjangoCeleryBeatIntervalschedule) error {
	var err error

	queries.SetScanner(&o.IntervalID, nil)
	if _, err = o.Update(exec, boil.Whitelist("interval_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Interval = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.IntervalDjangoCeleryBeatPeriodictasks {
		if queries.Equal(o.IntervalID, ri.IntervalID) {
			continue
		}

		ln := len(related.R.IntervalDjangoCeleryBeatPeriodictasks)
		if ln > 1 && i < ln-1 {
			related.R.IntervalDjangoCeleryBeatPeriodictasks[i] = related.R.IntervalDjangoCeleryBeatPeriodictasks[ln-1]
		}
		related.R.IntervalDjangoCeleryBeatPeriodictasks = related.R.IntervalDjangoCeleryBeatPeriodictasks[:ln-1]
		break
	}
	return nil
}

// SetSolar of the djangoCeleryBeatPeriodictask to the related item.
// Sets o.R.Solar to related.
// Adds o to related.R.SolarDjangoCeleryBeatPeriodictasks.
func (o *DjangoCeleryBeatPeriodictask) SetSolar(exec boil.Executor, insert bool, related *DjangoCeleryBeatSolarschedule) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"django_celery_beat_periodictask\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"solar_id"}),
		strmangle.WhereClause("\"", "\"", 2, djangoCeleryBeatPeriodictaskPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.SolarID, related.ID)
	if o.R == nil {
		o.R = &djangoCeleryBeatPeriodictaskR{
			Solar: related,
		}
	} else {
		o.R.Solar = related
	}

	if related.R == nil {
		related.R = &djangoCeleryBeatSolarscheduleR{
			SolarDjangoCeleryBeatPeriodictasks: DjangoCeleryBeatPeriodictaskSlice{o},
		}
	} else {
		related.R.SolarDjangoCeleryBeatPeriodictasks = append(related.R.SolarDjangoCeleryBeatPeriodictasks, o)
	}

	return nil
}

// RemoveSolar relationship.
// Sets o.R.Solar to nil.
// Removes o from all passed in related items' relationships struct.
func (o *DjangoCeleryBeatPeriodictask) RemoveSolar(exec boil.Executor, related *DjangoCeleryBeatSolarschedule) error {
	var err error

	queries.SetScanner(&o.SolarID, nil)
	if _, err = o.Update(exec, boil.Whitelist("solar_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Solar = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.SolarDjangoCeleryBeatPeriodictasks {
		if queries.Equal(o.SolarID, ri.SolarID) {
			continue
		}

		ln := len(related.R.SolarDjangoCeleryBeatPeriodictasks)
		if ln > 1 && i < ln-1 {
			related.R.SolarDjangoCeleryBeatPeriodictasks[i] = related.R.SolarDjangoCeleryBeatPeriodictasks[ln-1]
		}
		related.R.SolarDjangoCeleryBeatPeriodictasks = related.R.SolarDjangoCeleryBeatPeriodictasks[:ln-1]
		break
	}
	return nil
}

// DjangoCeleryBeatPeriodictasks retrieves all the records using an executor.
func DjangoCeleryBeatPeriodictasks(mods ...qm.QueryMod) djangoCeleryBeatPeriodictaskQuery {
	mods = append(mods, qm.From("\"django_celery_beat_periodictask\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"django_celery_beat_periodictask\".*"})
	}

	return djangoCeleryBeatPeriodictaskQuery{q}
}

// FindDjangoCeleryBeatPeriodictask retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindDjangoCeleryBeatPeriodictask(exec boil.Executor, iD int, selectCols ...string) (*DjangoCeleryBeatPeriodictask, error) {
	djangoCeleryBeatPeriodictaskObj := &DjangoCeleryBeatPeriodictask{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"django_celery_beat_periodictask\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(nil, exec, djangoCeleryBeatPeriodictaskObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "schema: unable to select from django_celery_beat_periodictask")
	}

	return djangoCeleryBeatPeriodictaskObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *DjangoCeleryBeatPeriodictask) Insert(exec boil.Executor, columns boil.Columns) error {
	if o == nil {
		return errors.New("schema: no django_celery_beat_periodictask provided for insertion")
	}

	var err error

	nzDefaults := queries.NonZeroDefaultSet(djangoCeleryBeatPeriodictaskColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	djangoCeleryBeatPeriodictaskInsertCacheMut.RLock()
	cache, cached := djangoCeleryBeatPeriodictaskInsertCache[key]
	djangoCeleryBeatPeriodictaskInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			djangoCeleryBeatPeriodictaskAllColumns,
			djangoCeleryBeatPeriodictaskColumnsWithDefault,
			djangoCeleryBeatPeriodictaskColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(djangoCeleryBeatPeriodictaskType, djangoCeleryBeatPeriodictaskMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(djangoCeleryBeatPeriodictaskType, djangoCeleryBeatPeriodictaskMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"django_celery_beat_periodictask\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"django_celery_beat_periodictask\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "schema: unable to insert into django_celery_beat_periodictask")
	}

	if !cached {
		djangoCeleryBeatPeriodictaskInsertCacheMut.Lock()
		djangoCeleryBeatPeriodictaskInsertCache[key] = cache
		djangoCeleryBeatPeriodictaskInsertCacheMut.Unlock()
	}

	return nil
}

// Update uses an executor to update the DjangoCeleryBeatPeriodictask.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *DjangoCeleryBeatPeriodictask) Update(exec boil.Executor, columns boil.Columns) (int64, error) {
	var err error
	key := makeCacheKey(columns, nil)
	djangoCeleryBeatPeriodictaskUpdateCacheMut.RLock()
	cache, cached := djangoCeleryBeatPeriodictaskUpdateCache[key]
	djangoCeleryBeatPeriodictaskUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			djangoCeleryBeatPeriodictaskAllColumns,
			djangoCeleryBeatPeriodictaskPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("schema: unable to update django_celery_beat_periodictask, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"django_celery_beat_periodictask\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, djangoCeleryBeatPeriodictaskPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(djangoCeleryBeatPeriodictaskType, djangoCeleryBeatPeriodictaskMapping, append(wl, djangoCeleryBeatPeriodictaskPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	var result sql.Result
	result, err = exec.Exec(cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to update django_celery_beat_periodictask row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "schema: failed to get rows affected by update for django_celery_beat_periodictask")
	}

	if !cached {
		djangoCeleryBeatPeriodictaskUpdateCacheMut.Lock()
		djangoCeleryBeatPeriodictaskUpdateCache[key] = cache
		djangoCeleryBeatPeriodictaskUpdateCacheMut.Unlock()
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values.
func (q djangoCeleryBeatPeriodictaskQuery) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to update all for django_celery_beat_periodictask")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to retrieve rows affected for django_celery_beat_periodictask")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o DjangoCeleryBeatPeriodictaskSlice) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("schema: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), djangoCeleryBeatPeriodictaskPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"django_celery_beat_periodictask\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, djangoCeleryBeatPeriodictaskPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to update all in djangoCeleryBeatPeriodictask slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to retrieve rows affected all in update all djangoCeleryBeatPeriodictask")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *DjangoCeleryBeatPeriodictask) Upsert(exec boil.Executor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("schema: no django_celery_beat_periodictask provided for upsert")
	}

	nzDefaults := queries.NonZeroDefaultSet(djangoCeleryBeatPeriodictaskColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	djangoCeleryBeatPeriodictaskUpsertCacheMut.RLock()
	cache, cached := djangoCeleryBeatPeriodictaskUpsertCache[key]
	djangoCeleryBeatPeriodictaskUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			djangoCeleryBeatPeriodictaskAllColumns,
			djangoCeleryBeatPeriodictaskColumnsWithDefault,
			djangoCeleryBeatPeriodictaskColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			djangoCeleryBeatPeriodictaskAllColumns,
			djangoCeleryBeatPeriodictaskPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("schema: unable to upsert django_celery_beat_periodictask, could not build update column list")
		}

		ret := strmangle.SetComplement(djangoCeleryBeatPeriodictaskAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(djangoCeleryBeatPeriodictaskPrimaryKeyColumns) == 0 {
				return errors.New("schema: unable to upsert django_celery_beat_periodictask, could not build conflict column list")
			}

			conflict = make([]string, len(djangoCeleryBeatPeriodictaskPrimaryKeyColumns))
			copy(conflict, djangoCeleryBeatPeriodictaskPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"django_celery_beat_periodictask\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(djangoCeleryBeatPeriodictaskType, djangoCeleryBeatPeriodictaskMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(djangoCeleryBeatPeriodictaskType, djangoCeleryBeatPeriodictaskMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "schema: unable to upsert django_celery_beat_periodictask")
	}

	if !cached {
		djangoCeleryBeatPeriodictaskUpsertCacheMut.Lock()
		djangoCeleryBeatPeriodictaskUpsertCache[key] = cache
		djangoCeleryBeatPeriodictaskUpsertCacheMut.Unlock()
	}

	return nil
}

// Delete deletes a single DjangoCeleryBeatPeriodictask record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *DjangoCeleryBeatPeriodictask) Delete(exec boil.Executor) (int64, error) {
	if o == nil {
		return 0, errors.New("schema: no DjangoCeleryBeatPeriodictask provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), djangoCeleryBeatPeriodictaskPrimaryKeyMapping)
	sql := "DELETE FROM \"django_celery_beat_periodictask\" WHERE \"id\"=$1"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to delete from django_celery_beat_periodictask")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "schema: failed to get rows affected by delete for django_celery_beat_periodictask")
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q djangoCeleryBeatPeriodictaskQuery) DeleteAll(exec boil.Executor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("schema: no djangoCeleryBeatPeriodictaskQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to delete all from django_celery_beat_periodictask")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "schema: failed to get rows affected by deleteall for django_celery_beat_periodictask")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o DjangoCeleryBeatPeriodictaskSlice) DeleteAll(exec boil.Executor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), djangoCeleryBeatPeriodictaskPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"django_celery_beat_periodictask\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, djangoCeleryBeatPeriodictaskPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to delete all from djangoCeleryBeatPeriodictask slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "schema: failed to get rows affected by deleteall for django_celery_beat_periodictask")
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *DjangoCeleryBeatPeriodictask) Reload(exec boil.Executor) error {
	ret, err := FindDjangoCeleryBeatPeriodictask(exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *DjangoCeleryBeatPeriodictaskSlice) ReloadAll(exec boil.Executor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := DjangoCeleryBeatPeriodictaskSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), djangoCeleryBeatPeriodictaskPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"django_celery_beat_periodictask\".* FROM \"django_celery_beat_periodictask\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, djangoCeleryBeatPeriodictaskPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(nil, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "schema: unable to reload all in DjangoCeleryBeatPeriodictaskSlice")
	}

	*o = slice

	return nil
}

// DjangoCeleryBeatPeriodictaskExists checks if the DjangoCeleryBeatPeriodictask row exists.
func DjangoCeleryBeatPeriodictaskExists(exec boil.Executor, iD int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"django_celery_beat_periodictask\" where \"id\"=$1 limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}
	row := exec.QueryRow(sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "schema: unable to check if django_celery_beat_periodictask exists")
	}

	return exists, nil
}

// Exists checks if the DjangoCeleryBeatPeriodictask row exists.
func (o *DjangoCeleryBeatPeriodictask) Exists(exec boil.Executor) (bool, error) {
	return DjangoCeleryBeatPeriodictaskExists(exec, o.ID)
}
