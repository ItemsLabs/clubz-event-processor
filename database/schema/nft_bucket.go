// Code generated by SQLBoiler 4.16.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package schema

import (
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// NFTBucket is an object representing the database table.
type NFTBucket struct {
	ID                    string       `boil:"id" json:"id" toml:"id" yaml:"id"`
	CreatedAt             time.Time    `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt             time.Time    `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`
	Name                  string       `boil:"name" json:"name" toml:"name" yaml:"name"`
	TeamID                null.String  `boil:"team_id" json:"team_id,omitempty" toml:"team_id" yaml:"team_id,omitempty"`
	Age                   null.Int     `boil:"age" json:"age,omitempty" toml:"age" yaml:"age,omitempty"`
	GamePosition          string       `boil:"game_position" json:"game_position" toml:"game_position" yaml:"game_position"`
	Position              string       `boil:"position" json:"position" toml:"position" yaml:"position"`
	CommonClaiming        null.Float64 `boil:"common_claiming" json:"common_claiming,omitempty" toml:"common_claiming" yaml:"common_claiming,omitempty"`
	CommonDefence         null.Float64 `boil:"common_defence" json:"common_defence,omitempty" toml:"common_defence" yaml:"common_defence,omitempty"`
	CommonDistribution    null.Float64 `boil:"common_distribution" json:"common_distribution,omitempty" toml:"common_distribution" yaml:"common_distribution,omitempty"`
	CommonDribbling       null.Float64 `boil:"common_dribbling" json:"common_dribbling,omitempty" toml:"common_dribbling" yaml:"common_dribbling,omitempty"`
	CommonPassing         null.Float64 `boil:"common_passing" json:"common_passing,omitempty" toml:"common_passing" yaml:"common_passing,omitempty"`
	CommonShooting        null.Float64 `boil:"common_shooting" json:"common_shooting,omitempty" toml:"common_shooting" yaml:"common_shooting,omitempty"`
	CommonStopping        null.Float64 `boil:"common_stopping" json:"common_stopping,omitempty" toml:"common_stopping" yaml:"common_stopping,omitempty"`
	LegendaryClaiming     null.Float64 `boil:"legendary_claiming" json:"legendary_claiming,omitempty" toml:"legendary_claiming" yaml:"legendary_claiming,omitempty"`
	LegendaryDefence      null.Float64 `boil:"legendary_defence" json:"legendary_defence,omitempty" toml:"legendary_defence" yaml:"legendary_defence,omitempty"`
	LegendaryDistribution null.Float64 `boil:"legendary_distribution" json:"legendary_distribution,omitempty" toml:"legendary_distribution" yaml:"legendary_distribution,omitempty"`
	LegendaryDribbling    null.Float64 `boil:"legendary_dribbling" json:"legendary_dribbling,omitempty" toml:"legendary_dribbling" yaml:"legendary_dribbling,omitempty"`
	LegendaryPassing      null.Float64 `boil:"legendary_passing" json:"legendary_passing,omitempty" toml:"legendary_passing" yaml:"legendary_passing,omitempty"`
	LegendaryShooting     null.Float64 `boil:"legendary_shooting" json:"legendary_shooting,omitempty" toml:"legendary_shooting" yaml:"legendary_shooting,omitempty"`
	LegendaryStopping     null.Float64 `boil:"legendary_stopping" json:"legendary_stopping,omitempty" toml:"legendary_stopping" yaml:"legendary_stopping,omitempty"`
	Nationality           null.String  `boil:"nationality" json:"nationality,omitempty" toml:"nationality" yaml:"nationality,omitempty"`
	RareClaiming          null.Float64 `boil:"rare_claiming" json:"rare_claiming,omitempty" toml:"rare_claiming" yaml:"rare_claiming,omitempty"`
	RareDefence           null.Float64 `boil:"rare_defence" json:"rare_defence,omitempty" toml:"rare_defence" yaml:"rare_defence,omitempty"`
	RareDistribution      null.Float64 `boil:"rare_distribution" json:"rare_distribution,omitempty" toml:"rare_distribution" yaml:"rare_distribution,omitempty"`
	RareDribbling         null.Float64 `boil:"rare_dribbling" json:"rare_dribbling,omitempty" toml:"rare_dribbling" yaml:"rare_dribbling,omitempty"`
	RarePassing           null.Float64 `boil:"rare_passing" json:"rare_passing,omitempty" toml:"rare_passing" yaml:"rare_passing,omitempty"`
	RareShooting          null.Float64 `boil:"rare_shooting" json:"rare_shooting,omitempty" toml:"rare_shooting" yaml:"rare_shooting,omitempty"`
	RareStopping          null.Float64 `boil:"rare_stopping" json:"rare_stopping,omitempty" toml:"rare_stopping" yaml:"rare_stopping,omitempty"`
	StarRating            float64      `boil:"star_rating" json:"star_rating" toml:"star_rating" yaml:"star_rating"`
	UltraRareClaiming     null.Float64 `boil:"ultra_rare_claiming" json:"ultra_rare_claiming,omitempty" toml:"ultra_rare_claiming" yaml:"ultra_rare_claiming,omitempty"`
	UltraRareDefence      null.Float64 `boil:"ultra_rare_defence" json:"ultra_rare_defence,omitempty" toml:"ultra_rare_defence" yaml:"ultra_rare_defence,omitempty"`
	UltraRareDistribution null.Float64 `boil:"ultra_rare_distribution" json:"ultra_rare_distribution,omitempty" toml:"ultra_rare_distribution" yaml:"ultra_rare_distribution,omitempty"`
	UltraRareDribbling    null.Float64 `boil:"ultra_rare_dribbling" json:"ultra_rare_dribbling,omitempty" toml:"ultra_rare_dribbling" yaml:"ultra_rare_dribbling,omitempty"`
	UltraRarePassing      null.Float64 `boil:"ultra_rare_passing" json:"ultra_rare_passing,omitempty" toml:"ultra_rare_passing" yaml:"ultra_rare_passing,omitempty"`
	UltraRareShooting     null.Float64 `boil:"ultra_rare_shooting" json:"ultra_rare_shooting,omitempty" toml:"ultra_rare_shooting" yaml:"ultra_rare_shooting,omitempty"`
	UltraRareStopping     null.Float64 `boil:"ultra_rare_stopping" json:"ultra_rare_stopping,omitempty" toml:"ultra_rare_stopping" yaml:"ultra_rare_stopping,omitempty"`
	UncommonClaiming      null.Float64 `boil:"uncommon_claiming" json:"uncommon_claiming,omitempty" toml:"uncommon_claiming" yaml:"uncommon_claiming,omitempty"`
	UncommonDefence       null.Float64 `boil:"uncommon_defence" json:"uncommon_defence,omitempty" toml:"uncommon_defence" yaml:"uncommon_defence,omitempty"`
	UncommonDistribution  null.Float64 `boil:"uncommon_distribution" json:"uncommon_distribution,omitempty" toml:"uncommon_distribution" yaml:"uncommon_distribution,omitempty"`
	UncommonDribbling     null.Float64 `boil:"uncommon_dribbling" json:"uncommon_dribbling,omitempty" toml:"uncommon_dribbling" yaml:"uncommon_dribbling,omitempty"`
	UncommonPassing       null.Float64 `boil:"uncommon_passing" json:"uncommon_passing,omitempty" toml:"uncommon_passing" yaml:"uncommon_passing,omitempty"`
	UncommonShooting      null.Float64 `boil:"uncommon_shooting" json:"uncommon_shooting,omitempty" toml:"uncommon_shooting" yaml:"uncommon_shooting,omitempty"`
	UncommonStopping      null.Float64 `boil:"uncommon_stopping" json:"uncommon_stopping,omitempty" toml:"uncommon_stopping" yaml:"uncommon_stopping,omitempty"`
	CommonImage           null.String  `boil:"common_image" json:"common_image,omitempty" toml:"common_image" yaml:"common_image,omitempty"`
	CommonMetadata        null.String  `boil:"common_metadata" json:"common_metadata,omitempty" toml:"common_metadata" yaml:"common_metadata,omitempty"`
	LegendaryImage        null.String  `boil:"legendary_image" json:"legendary_image,omitempty" toml:"legendary_image" yaml:"legendary_image,omitempty"`
	LegendaryMetadata     null.String  `boil:"legendary_metadata" json:"legendary_metadata,omitempty" toml:"legendary_metadata" yaml:"legendary_metadata,omitempty"`
	RareImage             null.String  `boil:"rare_image" json:"rare_image,omitempty" toml:"rare_image" yaml:"rare_image,omitempty"`
	RareMetadata          null.String  `boil:"rare_metadata" json:"rare_metadata,omitempty" toml:"rare_metadata" yaml:"rare_metadata,omitempty"`
	UltraRareImage        null.String  `boil:"ultra_rare_image" json:"ultra_rare_image,omitempty" toml:"ultra_rare_image" yaml:"ultra_rare_image,omitempty"`
	UltraRareMetadata     null.String  `boil:"ultra_rare_metadata" json:"ultra_rare_metadata,omitempty" toml:"ultra_rare_metadata" yaml:"ultra_rare_metadata,omitempty"`
	UncommonImage         null.String  `boil:"uncommon_image" json:"uncommon_image,omitempty" toml:"uncommon_image" yaml:"uncommon_image,omitempty"`
	UncommonMetadata      null.String  `boil:"uncommon_metadata" json:"uncommon_metadata,omitempty" toml:"uncommon_metadata" yaml:"uncommon_metadata,omitempty"`
	CommonLimit           null.Int     `boil:"common_limit" json:"common_limit,omitempty" toml:"common_limit" yaml:"common_limit,omitempty"`
	LegendaryLimit        null.Int     `boil:"legendary_limit" json:"legendary_limit,omitempty" toml:"legendary_limit" yaml:"legendary_limit,omitempty"`
	RareLimit             null.Int     `boil:"rare_limit" json:"rare_limit,omitempty" toml:"rare_limit" yaml:"rare_limit,omitempty"`
	UltraRareLimit        null.Int     `boil:"ultra_rare_limit" json:"ultra_rare_limit,omitempty" toml:"ultra_rare_limit" yaml:"ultra_rare_limit,omitempty"`
	UncommonLimit         null.Int     `boil:"uncommon_limit" json:"uncommon_limit,omitempty" toml:"uncommon_limit" yaml:"uncommon_limit,omitempty"`
	PlayersGroup          null.String  `boil:"players_group" json:"players_group,omitempty" toml:"players_group" yaml:"players_group,omitempty"`
	OptaID                null.String  `boil:"opta_id" json:"opta_id,omitempty" toml:"opta_id" yaml:"opta_id,omitempty"`

	R *nftBucketR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L nftBucketL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var NFTBucketColumns = struct {
	ID                    string
	CreatedAt             string
	UpdatedAt             string
	Name                  string
	TeamID                string
	Age                   string
	GamePosition          string
	Position              string
	CommonClaiming        string
	CommonDefence         string
	CommonDistribution    string
	CommonDribbling       string
	CommonPassing         string
	CommonShooting        string
	CommonStopping        string
	LegendaryClaiming     string
	LegendaryDefence      string
	LegendaryDistribution string
	LegendaryDribbling    string
	LegendaryPassing      string
	LegendaryShooting     string
	LegendaryStopping     string
	Nationality           string
	RareClaiming          string
	RareDefence           string
	RareDistribution      string
	RareDribbling         string
	RarePassing           string
	RareShooting          string
	RareStopping          string
	StarRating            string
	UltraRareClaiming     string
	UltraRareDefence      string
	UltraRareDistribution string
	UltraRareDribbling    string
	UltraRarePassing      string
	UltraRareShooting     string
	UltraRareStopping     string
	UncommonClaiming      string
	UncommonDefence       string
	UncommonDistribution  string
	UncommonDribbling     string
	UncommonPassing       string
	UncommonShooting      string
	UncommonStopping      string
	CommonImage           string
	CommonMetadata        string
	LegendaryImage        string
	LegendaryMetadata     string
	RareImage             string
	RareMetadata          string
	UltraRareImage        string
	UltraRareMetadata     string
	UncommonImage         string
	UncommonMetadata      string
	CommonLimit           string
	LegendaryLimit        string
	RareLimit             string
	UltraRareLimit        string
	UncommonLimit         string
	PlayersGroup          string
	OptaID                string
}{
	ID:                    "id",
	CreatedAt:             "created_at",
	UpdatedAt:             "updated_at",
	Name:                  "name",
	TeamID:                "team_id",
	Age:                   "age",
	GamePosition:          "game_position",
	Position:              "position",
	CommonClaiming:        "common_claiming",
	CommonDefence:         "common_defence",
	CommonDistribution:    "common_distribution",
	CommonDribbling:       "common_dribbling",
	CommonPassing:         "common_passing",
	CommonShooting:        "common_shooting",
	CommonStopping:        "common_stopping",
	LegendaryClaiming:     "legendary_claiming",
	LegendaryDefence:      "legendary_defence",
	LegendaryDistribution: "legendary_distribution",
	LegendaryDribbling:    "legendary_dribbling",
	LegendaryPassing:      "legendary_passing",
	LegendaryShooting:     "legendary_shooting",
	LegendaryStopping:     "legendary_stopping",
	Nationality:           "nationality",
	RareClaiming:          "rare_claiming",
	RareDefence:           "rare_defence",
	RareDistribution:      "rare_distribution",
	RareDribbling:         "rare_dribbling",
	RarePassing:           "rare_passing",
	RareShooting:          "rare_shooting",
	RareStopping:          "rare_stopping",
	StarRating:            "star_rating",
	UltraRareClaiming:     "ultra_rare_claiming",
	UltraRareDefence:      "ultra_rare_defence",
	UltraRareDistribution: "ultra_rare_distribution",
	UltraRareDribbling:    "ultra_rare_dribbling",
	UltraRarePassing:      "ultra_rare_passing",
	UltraRareShooting:     "ultra_rare_shooting",
	UltraRareStopping:     "ultra_rare_stopping",
	UncommonClaiming:      "uncommon_claiming",
	UncommonDefence:       "uncommon_defence",
	UncommonDistribution:  "uncommon_distribution",
	UncommonDribbling:     "uncommon_dribbling",
	UncommonPassing:       "uncommon_passing",
	UncommonShooting:      "uncommon_shooting",
	UncommonStopping:      "uncommon_stopping",
	CommonImage:           "common_image",
	CommonMetadata:        "common_metadata",
	LegendaryImage:        "legendary_image",
	LegendaryMetadata:     "legendary_metadata",
	RareImage:             "rare_image",
	RareMetadata:          "rare_metadata",
	UltraRareImage:        "ultra_rare_image",
	UltraRareMetadata:     "ultra_rare_metadata",
	UncommonImage:         "uncommon_image",
	UncommonMetadata:      "uncommon_metadata",
	CommonLimit:           "common_limit",
	LegendaryLimit:        "legendary_limit",
	RareLimit:             "rare_limit",
	UltraRareLimit:        "ultra_rare_limit",
	UncommonLimit:         "uncommon_limit",
	PlayersGroup:          "players_group",
	OptaID:                "opta_id",
}

var NFTBucketTableColumns = struct {
	ID                    string
	CreatedAt             string
	UpdatedAt             string
	Name                  string
	TeamID                string
	Age                   string
	GamePosition          string
	Position              string
	CommonClaiming        string
	CommonDefence         string
	CommonDistribution    string
	CommonDribbling       string
	CommonPassing         string
	CommonShooting        string
	CommonStopping        string
	LegendaryClaiming     string
	LegendaryDefence      string
	LegendaryDistribution string
	LegendaryDribbling    string
	LegendaryPassing      string
	LegendaryShooting     string
	LegendaryStopping     string
	Nationality           string
	RareClaiming          string
	RareDefence           string
	RareDistribution      string
	RareDribbling         string
	RarePassing           string
	RareShooting          string
	RareStopping          string
	StarRating            string
	UltraRareClaiming     string
	UltraRareDefence      string
	UltraRareDistribution string
	UltraRareDribbling    string
	UltraRarePassing      string
	UltraRareShooting     string
	UltraRareStopping     string
	UncommonClaiming      string
	UncommonDefence       string
	UncommonDistribution  string
	UncommonDribbling     string
	UncommonPassing       string
	UncommonShooting      string
	UncommonStopping      string
	CommonImage           string
	CommonMetadata        string
	LegendaryImage        string
	LegendaryMetadata     string
	RareImage             string
	RareMetadata          string
	UltraRareImage        string
	UltraRareMetadata     string
	UncommonImage         string
	UncommonMetadata      string
	CommonLimit           string
	LegendaryLimit        string
	RareLimit             string
	UltraRareLimit        string
	UncommonLimit         string
	PlayersGroup          string
	OptaID                string
}{
	ID:                    "nft_bucket.id",
	CreatedAt:             "nft_bucket.created_at",
	UpdatedAt:             "nft_bucket.updated_at",
	Name:                  "nft_bucket.name",
	TeamID:                "nft_bucket.team_id",
	Age:                   "nft_bucket.age",
	GamePosition:          "nft_bucket.game_position",
	Position:              "nft_bucket.position",
	CommonClaiming:        "nft_bucket.common_claiming",
	CommonDefence:         "nft_bucket.common_defence",
	CommonDistribution:    "nft_bucket.common_distribution",
	CommonDribbling:       "nft_bucket.common_dribbling",
	CommonPassing:         "nft_bucket.common_passing",
	CommonShooting:        "nft_bucket.common_shooting",
	CommonStopping:        "nft_bucket.common_stopping",
	LegendaryClaiming:     "nft_bucket.legendary_claiming",
	LegendaryDefence:      "nft_bucket.legendary_defence",
	LegendaryDistribution: "nft_bucket.legendary_distribution",
	LegendaryDribbling:    "nft_bucket.legendary_dribbling",
	LegendaryPassing:      "nft_bucket.legendary_passing",
	LegendaryShooting:     "nft_bucket.legendary_shooting",
	LegendaryStopping:     "nft_bucket.legendary_stopping",
	Nationality:           "nft_bucket.nationality",
	RareClaiming:          "nft_bucket.rare_claiming",
	RareDefence:           "nft_bucket.rare_defence",
	RareDistribution:      "nft_bucket.rare_distribution",
	RareDribbling:         "nft_bucket.rare_dribbling",
	RarePassing:           "nft_bucket.rare_passing",
	RareShooting:          "nft_bucket.rare_shooting",
	RareStopping:          "nft_bucket.rare_stopping",
	StarRating:            "nft_bucket.star_rating",
	UltraRareClaiming:     "nft_bucket.ultra_rare_claiming",
	UltraRareDefence:      "nft_bucket.ultra_rare_defence",
	UltraRareDistribution: "nft_bucket.ultra_rare_distribution",
	UltraRareDribbling:    "nft_bucket.ultra_rare_dribbling",
	UltraRarePassing:      "nft_bucket.ultra_rare_passing",
	UltraRareShooting:     "nft_bucket.ultra_rare_shooting",
	UltraRareStopping:     "nft_bucket.ultra_rare_stopping",
	UncommonClaiming:      "nft_bucket.uncommon_claiming",
	UncommonDefence:       "nft_bucket.uncommon_defence",
	UncommonDistribution:  "nft_bucket.uncommon_distribution",
	UncommonDribbling:     "nft_bucket.uncommon_dribbling",
	UncommonPassing:       "nft_bucket.uncommon_passing",
	UncommonShooting:      "nft_bucket.uncommon_shooting",
	UncommonStopping:      "nft_bucket.uncommon_stopping",
	CommonImage:           "nft_bucket.common_image",
	CommonMetadata:        "nft_bucket.common_metadata",
	LegendaryImage:        "nft_bucket.legendary_image",
	LegendaryMetadata:     "nft_bucket.legendary_metadata",
	RareImage:             "nft_bucket.rare_image",
	RareMetadata:          "nft_bucket.rare_metadata",
	UltraRareImage:        "nft_bucket.ultra_rare_image",
	UltraRareMetadata:     "nft_bucket.ultra_rare_metadata",
	UncommonImage:         "nft_bucket.uncommon_image",
	UncommonMetadata:      "nft_bucket.uncommon_metadata",
	CommonLimit:           "nft_bucket.common_limit",
	LegendaryLimit:        "nft_bucket.legendary_limit",
	RareLimit:             "nft_bucket.rare_limit",
	UltraRareLimit:        "nft_bucket.ultra_rare_limit",
	UncommonLimit:         "nft_bucket.uncommon_limit",
	PlayersGroup:          "nft_bucket.players_group",
	OptaID:                "nft_bucket.opta_id",
}

// Generated where

var NFTBucketWhere = struct {
	ID                    whereHelperstring
	CreatedAt             whereHelpertime_Time
	UpdatedAt             whereHelpertime_Time
	Name                  whereHelperstring
	TeamID                whereHelpernull_String
	Age                   whereHelpernull_Int
	GamePosition          whereHelperstring
	Position              whereHelperstring
	CommonClaiming        whereHelpernull_Float64
	CommonDefence         whereHelpernull_Float64
	CommonDistribution    whereHelpernull_Float64
	CommonDribbling       whereHelpernull_Float64
	CommonPassing         whereHelpernull_Float64
	CommonShooting        whereHelpernull_Float64
	CommonStopping        whereHelpernull_Float64
	LegendaryClaiming     whereHelpernull_Float64
	LegendaryDefence      whereHelpernull_Float64
	LegendaryDistribution whereHelpernull_Float64
	LegendaryDribbling    whereHelpernull_Float64
	LegendaryPassing      whereHelpernull_Float64
	LegendaryShooting     whereHelpernull_Float64
	LegendaryStopping     whereHelpernull_Float64
	Nationality           whereHelpernull_String
	RareClaiming          whereHelpernull_Float64
	RareDefence           whereHelpernull_Float64
	RareDistribution      whereHelpernull_Float64
	RareDribbling         whereHelpernull_Float64
	RarePassing           whereHelpernull_Float64
	RareShooting          whereHelpernull_Float64
	RareStopping          whereHelpernull_Float64
	StarRating            whereHelperfloat64
	UltraRareClaiming     whereHelpernull_Float64
	UltraRareDefence      whereHelpernull_Float64
	UltraRareDistribution whereHelpernull_Float64
	UltraRareDribbling    whereHelpernull_Float64
	UltraRarePassing      whereHelpernull_Float64
	UltraRareShooting     whereHelpernull_Float64
	UltraRareStopping     whereHelpernull_Float64
	UncommonClaiming      whereHelpernull_Float64
	UncommonDefence       whereHelpernull_Float64
	UncommonDistribution  whereHelpernull_Float64
	UncommonDribbling     whereHelpernull_Float64
	UncommonPassing       whereHelpernull_Float64
	UncommonShooting      whereHelpernull_Float64
	UncommonStopping      whereHelpernull_Float64
	CommonImage           whereHelpernull_String
	CommonMetadata        whereHelpernull_String
	LegendaryImage        whereHelpernull_String
	LegendaryMetadata     whereHelpernull_String
	RareImage             whereHelpernull_String
	RareMetadata          whereHelpernull_String
	UltraRareImage        whereHelpernull_String
	UltraRareMetadata     whereHelpernull_String
	UncommonImage         whereHelpernull_String
	UncommonMetadata      whereHelpernull_String
	CommonLimit           whereHelpernull_Int
	LegendaryLimit        whereHelpernull_Int
	RareLimit             whereHelpernull_Int
	UltraRareLimit        whereHelpernull_Int
	UncommonLimit         whereHelpernull_Int
	PlayersGroup          whereHelpernull_String
	OptaID                whereHelpernull_String
}{
	ID:                    whereHelperstring{field: "\"nft_bucket\".\"id\""},
	CreatedAt:             whereHelpertime_Time{field: "\"nft_bucket\".\"created_at\""},
	UpdatedAt:             whereHelpertime_Time{field: "\"nft_bucket\".\"updated_at\""},
	Name:                  whereHelperstring{field: "\"nft_bucket\".\"name\""},
	TeamID:                whereHelpernull_String{field: "\"nft_bucket\".\"team_id\""},
	Age:                   whereHelpernull_Int{field: "\"nft_bucket\".\"age\""},
	GamePosition:          whereHelperstring{field: "\"nft_bucket\".\"game_position\""},
	Position:              whereHelperstring{field: "\"nft_bucket\".\"position\""},
	CommonClaiming:        whereHelpernull_Float64{field: "\"nft_bucket\".\"common_claiming\""},
	CommonDefence:         whereHelpernull_Float64{field: "\"nft_bucket\".\"common_defence\""},
	CommonDistribution:    whereHelpernull_Float64{field: "\"nft_bucket\".\"common_distribution\""},
	CommonDribbling:       whereHelpernull_Float64{field: "\"nft_bucket\".\"common_dribbling\""},
	CommonPassing:         whereHelpernull_Float64{field: "\"nft_bucket\".\"common_passing\""},
	CommonShooting:        whereHelpernull_Float64{field: "\"nft_bucket\".\"common_shooting\""},
	CommonStopping:        whereHelpernull_Float64{field: "\"nft_bucket\".\"common_stopping\""},
	LegendaryClaiming:     whereHelpernull_Float64{field: "\"nft_bucket\".\"legendary_claiming\""},
	LegendaryDefence:      whereHelpernull_Float64{field: "\"nft_bucket\".\"legendary_defence\""},
	LegendaryDistribution: whereHelpernull_Float64{field: "\"nft_bucket\".\"legendary_distribution\""},
	LegendaryDribbling:    whereHelpernull_Float64{field: "\"nft_bucket\".\"legendary_dribbling\""},
	LegendaryPassing:      whereHelpernull_Float64{field: "\"nft_bucket\".\"legendary_passing\""},
	LegendaryShooting:     whereHelpernull_Float64{field: "\"nft_bucket\".\"legendary_shooting\""},
	LegendaryStopping:     whereHelpernull_Float64{field: "\"nft_bucket\".\"legendary_stopping\""},
	Nationality:           whereHelpernull_String{field: "\"nft_bucket\".\"nationality\""},
	RareClaiming:          whereHelpernull_Float64{field: "\"nft_bucket\".\"rare_claiming\""},
	RareDefence:           whereHelpernull_Float64{field: "\"nft_bucket\".\"rare_defence\""},
	RareDistribution:      whereHelpernull_Float64{field: "\"nft_bucket\".\"rare_distribution\""},
	RareDribbling:         whereHelpernull_Float64{field: "\"nft_bucket\".\"rare_dribbling\""},
	RarePassing:           whereHelpernull_Float64{field: "\"nft_bucket\".\"rare_passing\""},
	RareShooting:          whereHelpernull_Float64{field: "\"nft_bucket\".\"rare_shooting\""},
	RareStopping:          whereHelpernull_Float64{field: "\"nft_bucket\".\"rare_stopping\""},
	StarRating:            whereHelperfloat64{field: "\"nft_bucket\".\"star_rating\""},
	UltraRareClaiming:     whereHelpernull_Float64{field: "\"nft_bucket\".\"ultra_rare_claiming\""},
	UltraRareDefence:      whereHelpernull_Float64{field: "\"nft_bucket\".\"ultra_rare_defence\""},
	UltraRareDistribution: whereHelpernull_Float64{field: "\"nft_bucket\".\"ultra_rare_distribution\""},
	UltraRareDribbling:    whereHelpernull_Float64{field: "\"nft_bucket\".\"ultra_rare_dribbling\""},
	UltraRarePassing:      whereHelpernull_Float64{field: "\"nft_bucket\".\"ultra_rare_passing\""},
	UltraRareShooting:     whereHelpernull_Float64{field: "\"nft_bucket\".\"ultra_rare_shooting\""},
	UltraRareStopping:     whereHelpernull_Float64{field: "\"nft_bucket\".\"ultra_rare_stopping\""},
	UncommonClaiming:      whereHelpernull_Float64{field: "\"nft_bucket\".\"uncommon_claiming\""},
	UncommonDefence:       whereHelpernull_Float64{field: "\"nft_bucket\".\"uncommon_defence\""},
	UncommonDistribution:  whereHelpernull_Float64{field: "\"nft_bucket\".\"uncommon_distribution\""},
	UncommonDribbling:     whereHelpernull_Float64{field: "\"nft_bucket\".\"uncommon_dribbling\""},
	UncommonPassing:       whereHelpernull_Float64{field: "\"nft_bucket\".\"uncommon_passing\""},
	UncommonShooting:      whereHelpernull_Float64{field: "\"nft_bucket\".\"uncommon_shooting\""},
	UncommonStopping:      whereHelpernull_Float64{field: "\"nft_bucket\".\"uncommon_stopping\""},
	CommonImage:           whereHelpernull_String{field: "\"nft_bucket\".\"common_image\""},
	CommonMetadata:        whereHelpernull_String{field: "\"nft_bucket\".\"common_metadata\""},
	LegendaryImage:        whereHelpernull_String{field: "\"nft_bucket\".\"legendary_image\""},
	LegendaryMetadata:     whereHelpernull_String{field: "\"nft_bucket\".\"legendary_metadata\""},
	RareImage:             whereHelpernull_String{field: "\"nft_bucket\".\"rare_image\""},
	RareMetadata:          whereHelpernull_String{field: "\"nft_bucket\".\"rare_metadata\""},
	UltraRareImage:        whereHelpernull_String{field: "\"nft_bucket\".\"ultra_rare_image\""},
	UltraRareMetadata:     whereHelpernull_String{field: "\"nft_bucket\".\"ultra_rare_metadata\""},
	UncommonImage:         whereHelpernull_String{field: "\"nft_bucket\".\"uncommon_image\""},
	UncommonMetadata:      whereHelpernull_String{field: "\"nft_bucket\".\"uncommon_metadata\""},
	CommonLimit:           whereHelpernull_Int{field: "\"nft_bucket\".\"common_limit\""},
	LegendaryLimit:        whereHelpernull_Int{field: "\"nft_bucket\".\"legendary_limit\""},
	RareLimit:             whereHelpernull_Int{field: "\"nft_bucket\".\"rare_limit\""},
	UltraRareLimit:        whereHelpernull_Int{field: "\"nft_bucket\".\"ultra_rare_limit\""},
	UncommonLimit:         whereHelpernull_Int{field: "\"nft_bucket\".\"uncommon_limit\""},
	PlayersGroup:          whereHelpernull_String{field: "\"nft_bucket\".\"players_group\""},
	OptaID:                whereHelpernull_String{field: "\"nft_bucket\".\"opta_id\""},
}

// NFTBucketRels is where relationship names are stored.
var NFTBucketRels = struct {
	PlayerNFTAssignedPlayers string
}{
	PlayerNFTAssignedPlayers: "PlayerNFTAssignedPlayers",
}

// nftBucketR is where relationships are stored.
type nftBucketR struct {
	PlayerNFTAssignedPlayers AssignedPlayerSlice `boil:"PlayerNFTAssignedPlayers" json:"PlayerNFTAssignedPlayers" toml:"PlayerNFTAssignedPlayers" yaml:"PlayerNFTAssignedPlayers"`
}

// NewStruct creates a new relationship struct
func (*nftBucketR) NewStruct() *nftBucketR {
	return &nftBucketR{}
}

func (r *nftBucketR) GetPlayerNFTAssignedPlayers() AssignedPlayerSlice {
	if r == nil {
		return nil
	}
	return r.PlayerNFTAssignedPlayers
}

// nftBucketL is where Load methods for each relationship are stored.
type nftBucketL struct{}

var (
	nftBucketAllColumns            = []string{"id", "created_at", "updated_at", "name", "team_id", "age", "game_position", "position", "common_claiming", "common_defence", "common_distribution", "common_dribbling", "common_passing", "common_shooting", "common_stopping", "legendary_claiming", "legendary_defence", "legendary_distribution", "legendary_dribbling", "legendary_passing", "legendary_shooting", "legendary_stopping", "nationality", "rare_claiming", "rare_defence", "rare_distribution", "rare_dribbling", "rare_passing", "rare_shooting", "rare_stopping", "star_rating", "ultra_rare_claiming", "ultra_rare_defence", "ultra_rare_distribution", "ultra_rare_dribbling", "ultra_rare_passing", "ultra_rare_shooting", "ultra_rare_stopping", "uncommon_claiming", "uncommon_defence", "uncommon_distribution", "uncommon_dribbling", "uncommon_passing", "uncommon_shooting", "uncommon_stopping", "common_image", "common_metadata", "legendary_image", "legendary_metadata", "rare_image", "rare_metadata", "ultra_rare_image", "ultra_rare_metadata", "uncommon_image", "uncommon_metadata", "common_limit", "legendary_limit", "rare_limit", "ultra_rare_limit", "uncommon_limit", "players_group", "opta_id"}
	nftBucketColumnsWithoutDefault = []string{"id", "created_at", "updated_at", "name", "game_position", "position", "star_rating"}
	nftBucketColumnsWithDefault    = []string{"team_id", "age", "common_claiming", "common_defence", "common_distribution", "common_dribbling", "common_passing", "common_shooting", "common_stopping", "legendary_claiming", "legendary_defence", "legendary_distribution", "legendary_dribbling", "legendary_passing", "legendary_shooting", "legendary_stopping", "nationality", "rare_claiming", "rare_defence", "rare_distribution", "rare_dribbling", "rare_passing", "rare_shooting", "rare_stopping", "ultra_rare_claiming", "ultra_rare_defence", "ultra_rare_distribution", "ultra_rare_dribbling", "ultra_rare_passing", "ultra_rare_shooting", "ultra_rare_stopping", "uncommon_claiming", "uncommon_defence", "uncommon_distribution", "uncommon_dribbling", "uncommon_passing", "uncommon_shooting", "uncommon_stopping", "common_image", "common_metadata", "legendary_image", "legendary_metadata", "rare_image", "rare_metadata", "ultra_rare_image", "ultra_rare_metadata", "uncommon_image", "uncommon_metadata", "common_limit", "legendary_limit", "rare_limit", "ultra_rare_limit", "uncommon_limit", "players_group", "opta_id"}
	nftBucketPrimaryKeyColumns     = []string{"id"}
	nftBucketGeneratedColumns      = []string{}
)

type (
	// NFTBucketSlice is an alias for a slice of pointers to NFTBucket.
	// This should almost always be used instead of []NFTBucket.
	NFTBucketSlice []*NFTBucket

	nftBucketQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	nftBucketType                 = reflect.TypeOf(&NFTBucket{})
	nftBucketMapping              = queries.MakeStructMapping(nftBucketType)
	nftBucketPrimaryKeyMapping, _ = queries.BindMapping(nftBucketType, nftBucketMapping, nftBucketPrimaryKeyColumns)
	nftBucketInsertCacheMut       sync.RWMutex
	nftBucketInsertCache          = make(map[string]insertCache)
	nftBucketUpdateCacheMut       sync.RWMutex
	nftBucketUpdateCache          = make(map[string]updateCache)
	nftBucketUpsertCacheMut       sync.RWMutex
	nftBucketUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// One returns a single nftBucket record from the query.
func (q nftBucketQuery) One(exec boil.Executor) (*NFTBucket, error) {
	o := &NFTBucket{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(nil, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "schema: failed to execute a one query for nft_bucket")
	}

	return o, nil
}

// All returns all NFTBucket records from the query.
func (q nftBucketQuery) All(exec boil.Executor) (NFTBucketSlice, error) {
	var o []*NFTBucket

	err := q.Bind(nil, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "schema: failed to assign all query results to NFTBucket slice")
	}

	return o, nil
}

// Count returns the count of all NFTBucket records in the query.
func (q nftBucketQuery) Count(exec boil.Executor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "schema: failed to count nft_bucket rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q nftBucketQuery) Exists(exec boil.Executor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "schema: failed to check if nft_bucket exists")
	}

	return count > 0, nil
}

// PlayerNFTAssignedPlayers retrieves all the assigned_player's AssignedPlayers with an executor via player_nft_id column.
func (o *NFTBucket) PlayerNFTAssignedPlayers(mods ...qm.QueryMod) assignedPlayerQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"assigned_players\".\"player_nft_id\"=?", o.ID),
	)

	return AssignedPlayers(queryMods...)
}

// LoadPlayerNFTAssignedPlayers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (nftBucketL) LoadPlayerNFTAssignedPlayers(e boil.Executor, singular bool, maybeNFTBucket interface{}, mods queries.Applicator) error {
	var slice []*NFTBucket
	var object *NFTBucket

	if singular {
		var ok bool
		object, ok = maybeNFTBucket.(*NFTBucket)
		if !ok {
			object = new(NFTBucket)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeNFTBucket)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeNFTBucket))
			}
		}
	} else {
		s, ok := maybeNFTBucket.(*[]*NFTBucket)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeNFTBucket)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeNFTBucket))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &nftBucketR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &nftBucketR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`assigned_players`),
		qm.WhereIn(`assigned_players.player_nft_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load assigned_players")
	}

	var resultSlice []*AssignedPlayer
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice assigned_players")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on assigned_players")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for assigned_players")
	}

	if singular {
		object.R.PlayerNFTAssignedPlayers = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &assignedPlayerR{}
			}
			foreign.R.PlayerNFT = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.PlayerNFTID) {
				local.R.PlayerNFTAssignedPlayers = append(local.R.PlayerNFTAssignedPlayers, foreign)
				if foreign.R == nil {
					foreign.R = &assignedPlayerR{}
				}
				foreign.R.PlayerNFT = local
				break
			}
		}
	}

	return nil
}

// AddPlayerNFTAssignedPlayers adds the given related objects to the existing relationships
// of the nft_bucket, optionally inserting them as new records.
// Appends related to o.R.PlayerNFTAssignedPlayers.
// Sets related.R.PlayerNFT appropriately.
func (o *NFTBucket) AddPlayerNFTAssignedPlayers(exec boil.Executor, insert bool, related ...*AssignedPlayer) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.PlayerNFTID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"assigned_players\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_nft_id"}),
				strmangle.WhereClause("\"", "\"", 2, assignedPlayerPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.PlayerNFTID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &nftBucketR{
			PlayerNFTAssignedPlayers: related,
		}
	} else {
		o.R.PlayerNFTAssignedPlayers = append(o.R.PlayerNFTAssignedPlayers, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &assignedPlayerR{
				PlayerNFT: o,
			}
		} else {
			rel.R.PlayerNFT = o
		}
	}
	return nil
}

// SetPlayerNFTAssignedPlayers removes all previously related items of the
// nft_bucket replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.PlayerNFT's PlayerNFTAssignedPlayers accordingly.
// Replaces o.R.PlayerNFTAssignedPlayers with related.
// Sets related.R.PlayerNFT's PlayerNFTAssignedPlayers accordingly.
func (o *NFTBucket) SetPlayerNFTAssignedPlayers(exec boil.Executor, insert bool, related ...*AssignedPlayer) error {
	query := "update \"assigned_players\" set \"player_nft_id\" = null where \"player_nft_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.PlayerNFTAssignedPlayers {
			queries.SetScanner(&rel.PlayerNFTID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.PlayerNFT = nil
		}
		o.R.PlayerNFTAssignedPlayers = nil
	}

	return o.AddPlayerNFTAssignedPlayers(exec, insert, related...)
}

// RemovePlayerNFTAssignedPlayers relationships from objects passed in.
// Removes related items from R.PlayerNFTAssignedPlayers (uses pointer comparison, removal does not keep order)
// Sets related.R.PlayerNFT.
func (o *NFTBucket) RemovePlayerNFTAssignedPlayers(exec boil.Executor, related ...*AssignedPlayer) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.PlayerNFTID, nil)
		if rel.R != nil {
			rel.R.PlayerNFT = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("player_nft_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.PlayerNFTAssignedPlayers {
			if rel != ri {
				continue
			}

			ln := len(o.R.PlayerNFTAssignedPlayers)
			if ln > 1 && i < ln-1 {
				o.R.PlayerNFTAssignedPlayers[i] = o.R.PlayerNFTAssignedPlayers[ln-1]
			}
			o.R.PlayerNFTAssignedPlayers = o.R.PlayerNFTAssignedPlayers[:ln-1]
			break
		}
	}

	return nil
}

// NFTBuckets retrieves all the records using an executor.
func NFTBuckets(mods ...qm.QueryMod) nftBucketQuery {
	mods = append(mods, qm.From("\"nft_bucket\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"nft_bucket\".*"})
	}

	return nftBucketQuery{q}
}

// FindNFTBucket retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindNFTBucket(exec boil.Executor, iD string, selectCols ...string) (*NFTBucket, error) {
	nftBucketObj := &NFTBucket{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"nft_bucket\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(nil, exec, nftBucketObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "schema: unable to select from nft_bucket")
	}

	return nftBucketObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *NFTBucket) Insert(exec boil.Executor, columns boil.Columns) error {
	if o == nil {
		return errors.New("schema: no nft_bucket provided for insertion")
	}

	var err error
	currTime := time.Now().In(boil.GetLocation())

	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}
	if o.UpdatedAt.IsZero() {
		o.UpdatedAt = currTime
	}

	nzDefaults := queries.NonZeroDefaultSet(nftBucketColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	nftBucketInsertCacheMut.RLock()
	cache, cached := nftBucketInsertCache[key]
	nftBucketInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			nftBucketAllColumns,
			nftBucketColumnsWithDefault,
			nftBucketColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(nftBucketType, nftBucketMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(nftBucketType, nftBucketMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"nft_bucket\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"nft_bucket\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "schema: unable to insert into nft_bucket")
	}

	if !cached {
		nftBucketInsertCacheMut.Lock()
		nftBucketInsertCache[key] = cache
		nftBucketInsertCacheMut.Unlock()
	}

	return nil
}

// Update uses an executor to update the NFTBucket.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *NFTBucket) Update(exec boil.Executor, columns boil.Columns) (int64, error) {
	currTime := time.Now().In(boil.GetLocation())

	o.UpdatedAt = currTime

	var err error
	key := makeCacheKey(columns, nil)
	nftBucketUpdateCacheMut.RLock()
	cache, cached := nftBucketUpdateCache[key]
	nftBucketUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			nftBucketAllColumns,
			nftBucketPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("schema: unable to update nft_bucket, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"nft_bucket\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, nftBucketPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(nftBucketType, nftBucketMapping, append(wl, nftBucketPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	var result sql.Result
	result, err = exec.Exec(cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to update nft_bucket row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "schema: failed to get rows affected by update for nft_bucket")
	}

	if !cached {
		nftBucketUpdateCacheMut.Lock()
		nftBucketUpdateCache[key] = cache
		nftBucketUpdateCacheMut.Unlock()
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values.
func (q nftBucketQuery) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to update all for nft_bucket")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to retrieve rows affected for nft_bucket")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o NFTBucketSlice) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("schema: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), nftBucketPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"nft_bucket\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, nftBucketPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to update all in nftBucket slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to retrieve rows affected all in update all nftBucket")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *NFTBucket) Upsert(exec boil.Executor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("schema: no nft_bucket provided for upsert")
	}
	currTime := time.Now().In(boil.GetLocation())

	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}
	o.UpdatedAt = currTime

	nzDefaults := queries.NonZeroDefaultSet(nftBucketColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	nftBucketUpsertCacheMut.RLock()
	cache, cached := nftBucketUpsertCache[key]
	nftBucketUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			nftBucketAllColumns,
			nftBucketColumnsWithDefault,
			nftBucketColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			nftBucketAllColumns,
			nftBucketPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("schema: unable to upsert nft_bucket, could not build update column list")
		}

		ret := strmangle.SetComplement(nftBucketAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(nftBucketPrimaryKeyColumns) == 0 {
				return errors.New("schema: unable to upsert nft_bucket, could not build conflict column list")
			}

			conflict = make([]string, len(nftBucketPrimaryKeyColumns))
			copy(conflict, nftBucketPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"nft_bucket\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(nftBucketType, nftBucketMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(nftBucketType, nftBucketMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "schema: unable to upsert nft_bucket")
	}

	if !cached {
		nftBucketUpsertCacheMut.Lock()
		nftBucketUpsertCache[key] = cache
		nftBucketUpsertCacheMut.Unlock()
	}

	return nil
}

// Delete deletes a single NFTBucket record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *NFTBucket) Delete(exec boil.Executor) (int64, error) {
	if o == nil {
		return 0, errors.New("schema: no NFTBucket provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), nftBucketPrimaryKeyMapping)
	sql := "DELETE FROM \"nft_bucket\" WHERE \"id\"=$1"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to delete from nft_bucket")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "schema: failed to get rows affected by delete for nft_bucket")
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q nftBucketQuery) DeleteAll(exec boil.Executor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("schema: no nftBucketQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to delete all from nft_bucket")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "schema: failed to get rows affected by deleteall for nft_bucket")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o NFTBucketSlice) DeleteAll(exec boil.Executor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), nftBucketPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"nft_bucket\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, nftBucketPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to delete all from nftBucket slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "schema: failed to get rows affected by deleteall for nft_bucket")
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *NFTBucket) Reload(exec boil.Executor) error {
	ret, err := FindNFTBucket(exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *NFTBucketSlice) ReloadAll(exec boil.Executor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := NFTBucketSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), nftBucketPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"nft_bucket\".* FROM \"nft_bucket\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, nftBucketPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(nil, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "schema: unable to reload all in NFTBucketSlice")
	}

	*o = slice

	return nil
}

// NFTBucketExists checks if the NFTBucket row exists.
func NFTBucketExists(exec boil.Executor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"nft_bucket\" where \"id\"=$1 limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}
	row := exec.QueryRow(sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "schema: unable to check if nft_bucket exists")
	}

	return exists, nil
}

// Exists checks if the NFTBucket row exists.
func (o *NFTBucket) Exists(exec boil.Executor) (bool, error) {
	return NFTBucketExists(exec, o.ID)
}
