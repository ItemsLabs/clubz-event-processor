// Code generated by SQLBoiler 4.16.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package schema

import (
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// Match is an object representing the database table.
type Match struct {
	ID                    string      `boil:"id" json:"id" toml:"id" yaml:"id"`
	CreatedAt             time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt             time.Time   `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`
	ImportID              null.String `boil:"import_id" json:"import_id,omitempty" toml:"import_id" yaml:"import_id,omitempty"`
	MatchTime             time.Time   `boil:"match_time" json:"match_time" toml:"match_time" yaml:"match_time"`
	LastProcessedID       null.String `boil:"last_processed_id" json:"last_processed_id,omitempty" toml:"last_processed_id" yaml:"last_processed_id,omitempty"`
	AwayTeamID            string      `boil:"away_team_id" json:"away_team_id" toml:"away_team_id" yaml:"away_team_id"`
	CompetitionID         string      `boil:"competition_id" json:"competition_id" toml:"competition_id" yaml:"competition_id"`
	HomeTeamID            string      `boil:"home_team_id" json:"home_team_id" toml:"home_team_id" yaml:"home_team_id"`
	SeasonID              string      `boil:"season_id" json:"season_id" toml:"season_id" yaml:"season_id"`
	HomeScore             int         `boil:"home_score" json:"home_score" toml:"home_score" yaml:"home_score"`
	AwayScore             int         `boil:"away_score" json:"away_score" toml:"away_score" yaml:"away_score"`
	MatchEnd              null.Time   `boil:"match_end" json:"match_end,omitempty" toml:"match_end" yaml:"match_end,omitempty"`
	FStart                null.Time   `boil:"f_start" json:"f_start,omitempty" toml:"f_start" yaml:"f_start,omitempty"`
	FEnd                  null.Time   `boil:"f_end" json:"f_end,omitempty" toml:"f_end" yaml:"f_end,omitempty"`
	SStart                null.Time   `boil:"s_start" json:"s_start,omitempty" toml:"s_start" yaml:"s_start,omitempty"`
	SEnd                  null.Time   `boil:"s_end" json:"s_end,omitempty" toml:"s_end" yaml:"s_end,omitempty"`
	X1Start               null.Time   `boil:"x1_start" json:"x1_start,omitempty" toml:"x1_start" yaml:"x1_start,omitempty"`
	X1End                 null.Time   `boil:"x1_end" json:"x1_end,omitempty" toml:"x1_end" yaml:"x1_end,omitempty"`
	X2Start               null.Time   `boil:"x2_start" json:"x2_start,omitempty" toml:"x2_start" yaml:"x2_start,omitempty"`
	X2End                 null.Time   `boil:"x2_end" json:"x2_end,omitempty" toml:"x2_end" yaml:"x2_end,omitempty"`
	PStart                null.Time   `boil:"p_start" json:"p_start,omitempty" toml:"p_start" yaml:"p_start,omitempty"`
	PEnd                  null.Time   `boil:"p_end" json:"p_end,omitempty" toml:"p_end" yaml:"p_end,omitempty"`
	Version               int         `boil:"version" json:"version" toml:"version" yaml:"version"`
	SimulationFromMatchID null.String `boil:"simulation_from_match_id" json:"simulation_from_match_id,omitempty" toml:"simulation_from_match_id" yaml:"simulation_from_match_id,omitempty"`
	HasLineups            bool        `boil:"has_lineups" json:"has_lineups" toml:"has_lineups" yaml:"has_lineups"`
	Period                string      `boil:"period" json:"period" toml:"period" yaml:"period"`
	Status                string      `boil:"status" json:"status" toml:"status" yaml:"status"`
	MatchType             int         `boil:"match_type" json:"match_type" toml:"match_type" yaml:"match_type"`
	Minute                int         `boil:"minute" json:"minute" toml:"minute" yaml:"minute"`
	Second                int         `boil:"second" json:"second" toml:"second" yaml:"second"`
	Rewarded              bool        `boil:"rewarded" json:"rewarded" toml:"rewarded" yaml:"rewarded"`
	LastSyncedAt          null.Time   `boil:"last_synced_at" json:"last_synced_at,omitempty" toml:"last_synced_at" yaml:"last_synced_at,omitempty"`
	AwayTeamSelectionID   null.String `boil:"away_team_selection_id" json:"away_team_selection_id,omitempty" toml:"away_team_selection_id" yaml:"away_team_selection_id,omitempty"`
	HomeTeamSelectionID   null.String `boil:"home_team_selection_id" json:"home_team_selection_id,omitempty" toml:"home_team_selection_id" yaml:"home_team_selection_id,omitempty"`
	MatchDayID            null.String `boil:"match_day_id" json:"match_day_id,omitempty" toml:"match_day_id" yaml:"match_day_id,omitempty"`
	EditionID             null.String `boil:"edition_id" json:"edition_id,omitempty" toml:"edition_id" yaml:"edition_id,omitempty"`
	Week                  int         `boil:"week" json:"week" toml:"week" yaml:"week"`
	SportID               null.String `boil:"sport_id" json:"sport_id,omitempty" toml:"sport_id" yaml:"sport_id,omitempty"`
	Enabled               bool        `boil:"enabled" json:"enabled" toml:"enabled" yaml:"enabled"`

	R *matchR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L matchL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var MatchColumns = struct {
	ID                    string
	CreatedAt             string
	UpdatedAt             string
	ImportID              string
	MatchTime             string
	LastProcessedID       string
	AwayTeamID            string
	CompetitionID         string
	HomeTeamID            string
	SeasonID              string
	HomeScore             string
	AwayScore             string
	MatchEnd              string
	FStart                string
	FEnd                  string
	SStart                string
	SEnd                  string
	X1Start               string
	X1End                 string
	X2Start               string
	X2End                 string
	PStart                string
	PEnd                  string
	Version               string
	SimulationFromMatchID string
	HasLineups            string
	Period                string
	Status                string
	MatchType             string
	Minute                string
	Second                string
	Rewarded              string
	LastSyncedAt          string
	AwayTeamSelectionID   string
	HomeTeamSelectionID   string
	MatchDayID            string
	EditionID             string
	Week                  string
	SportID               string
	Enabled               string
}{
	ID:                    "id",
	CreatedAt:             "created_at",
	UpdatedAt:             "updated_at",
	ImportID:              "import_id",
	MatchTime:             "match_time",
	LastProcessedID:       "last_processed_id",
	AwayTeamID:            "away_team_id",
	CompetitionID:         "competition_id",
	HomeTeamID:            "home_team_id",
	SeasonID:              "season_id",
	HomeScore:             "home_score",
	AwayScore:             "away_score",
	MatchEnd:              "match_end",
	FStart:                "f_start",
	FEnd:                  "f_end",
	SStart:                "s_start",
	SEnd:                  "s_end",
	X1Start:               "x1_start",
	X1End:                 "x1_end",
	X2Start:               "x2_start",
	X2End:                 "x2_end",
	PStart:                "p_start",
	PEnd:                  "p_end",
	Version:               "version",
	SimulationFromMatchID: "simulation_from_match_id",
	HasLineups:            "has_lineups",
	Period:                "period",
	Status:                "status",
	MatchType:             "match_type",
	Minute:                "minute",
	Second:                "second",
	Rewarded:              "rewarded",
	LastSyncedAt:          "last_synced_at",
	AwayTeamSelectionID:   "away_team_selection_id",
	HomeTeamSelectionID:   "home_team_selection_id",
	MatchDayID:            "match_day_id",
	EditionID:             "edition_id",
	Week:                  "week",
	SportID:               "sport_id",
	Enabled:               "enabled",
}

var MatchTableColumns = struct {
	ID                    string
	CreatedAt             string
	UpdatedAt             string
	ImportID              string
	MatchTime             string
	LastProcessedID       string
	AwayTeamID            string
	CompetitionID         string
	HomeTeamID            string
	SeasonID              string
	HomeScore             string
	AwayScore             string
	MatchEnd              string
	FStart                string
	FEnd                  string
	SStart                string
	SEnd                  string
	X1Start               string
	X1End                 string
	X2Start               string
	X2End                 string
	PStart                string
	PEnd                  string
	Version               string
	SimulationFromMatchID string
	HasLineups            string
	Period                string
	Status                string
	MatchType             string
	Minute                string
	Second                string
	Rewarded              string
	LastSyncedAt          string
	AwayTeamSelectionID   string
	HomeTeamSelectionID   string
	MatchDayID            string
	EditionID             string
	Week                  string
	SportID               string
	Enabled               string
}{
	ID:                    "matches.id",
	CreatedAt:             "matches.created_at",
	UpdatedAt:             "matches.updated_at",
	ImportID:              "matches.import_id",
	MatchTime:             "matches.match_time",
	LastProcessedID:       "matches.last_processed_id",
	AwayTeamID:            "matches.away_team_id",
	CompetitionID:         "matches.competition_id",
	HomeTeamID:            "matches.home_team_id",
	SeasonID:              "matches.season_id",
	HomeScore:             "matches.home_score",
	AwayScore:             "matches.away_score",
	MatchEnd:              "matches.match_end",
	FStart:                "matches.f_start",
	FEnd:                  "matches.f_end",
	SStart:                "matches.s_start",
	SEnd:                  "matches.s_end",
	X1Start:               "matches.x1_start",
	X1End:                 "matches.x1_end",
	X2Start:               "matches.x2_start",
	X2End:                 "matches.x2_end",
	PStart:                "matches.p_start",
	PEnd:                  "matches.p_end",
	Version:               "matches.version",
	SimulationFromMatchID: "matches.simulation_from_match_id",
	HasLineups:            "matches.has_lineups",
	Period:                "matches.period",
	Status:                "matches.status",
	MatchType:             "matches.match_type",
	Minute:                "matches.minute",
	Second:                "matches.second",
	Rewarded:              "matches.rewarded",
	LastSyncedAt:          "matches.last_synced_at",
	AwayTeamSelectionID:   "matches.away_team_selection_id",
	HomeTeamSelectionID:   "matches.home_team_selection_id",
	MatchDayID:            "matches.match_day_id",
	EditionID:             "matches.edition_id",
	Week:                  "matches.week",
	SportID:               "matches.sport_id",
	Enabled:               "matches.enabled",
}

// Generated where

var MatchWhere = struct {
	ID                    whereHelperstring
	CreatedAt             whereHelpertime_Time
	UpdatedAt             whereHelpertime_Time
	ImportID              whereHelpernull_String
	MatchTime             whereHelpertime_Time
	LastProcessedID       whereHelpernull_String
	AwayTeamID            whereHelperstring
	CompetitionID         whereHelperstring
	HomeTeamID            whereHelperstring
	SeasonID              whereHelperstring
	HomeScore             whereHelperint
	AwayScore             whereHelperint
	MatchEnd              whereHelpernull_Time
	FStart                whereHelpernull_Time
	FEnd                  whereHelpernull_Time
	SStart                whereHelpernull_Time
	SEnd                  whereHelpernull_Time
	X1Start               whereHelpernull_Time
	X1End                 whereHelpernull_Time
	X2Start               whereHelpernull_Time
	X2End                 whereHelpernull_Time
	PStart                whereHelpernull_Time
	PEnd                  whereHelpernull_Time
	Version               whereHelperint
	SimulationFromMatchID whereHelpernull_String
	HasLineups            whereHelperbool
	Period                whereHelperstring
	Status                whereHelperstring
	MatchType             whereHelperint
	Minute                whereHelperint
	Second                whereHelperint
	Rewarded              whereHelperbool
	LastSyncedAt          whereHelpernull_Time
	AwayTeamSelectionID   whereHelpernull_String
	HomeTeamSelectionID   whereHelpernull_String
	MatchDayID            whereHelpernull_String
	EditionID             whereHelpernull_String
	Week                  whereHelperint
	SportID               whereHelpernull_String
	Enabled               whereHelperbool
}{
	ID:                    whereHelperstring{field: "\"matches\".\"id\""},
	CreatedAt:             whereHelpertime_Time{field: "\"matches\".\"created_at\""},
	UpdatedAt:             whereHelpertime_Time{field: "\"matches\".\"updated_at\""},
	ImportID:              whereHelpernull_String{field: "\"matches\".\"import_id\""},
	MatchTime:             whereHelpertime_Time{field: "\"matches\".\"match_time\""},
	LastProcessedID:       whereHelpernull_String{field: "\"matches\".\"last_processed_id\""},
	AwayTeamID:            whereHelperstring{field: "\"matches\".\"away_team_id\""},
	CompetitionID:         whereHelperstring{field: "\"matches\".\"competition_id\""},
	HomeTeamID:            whereHelperstring{field: "\"matches\".\"home_team_id\""},
	SeasonID:              whereHelperstring{field: "\"matches\".\"season_id\""},
	HomeScore:             whereHelperint{field: "\"matches\".\"home_score\""},
	AwayScore:             whereHelperint{field: "\"matches\".\"away_score\""},
	MatchEnd:              whereHelpernull_Time{field: "\"matches\".\"match_end\""},
	FStart:                whereHelpernull_Time{field: "\"matches\".\"f_start\""},
	FEnd:                  whereHelpernull_Time{field: "\"matches\".\"f_end\""},
	SStart:                whereHelpernull_Time{field: "\"matches\".\"s_start\""},
	SEnd:                  whereHelpernull_Time{field: "\"matches\".\"s_end\""},
	X1Start:               whereHelpernull_Time{field: "\"matches\".\"x1_start\""},
	X1End:                 whereHelpernull_Time{field: "\"matches\".\"x1_end\""},
	X2Start:               whereHelpernull_Time{field: "\"matches\".\"x2_start\""},
	X2End:                 whereHelpernull_Time{field: "\"matches\".\"x2_end\""},
	PStart:                whereHelpernull_Time{field: "\"matches\".\"p_start\""},
	PEnd:                  whereHelpernull_Time{field: "\"matches\".\"p_end\""},
	Version:               whereHelperint{field: "\"matches\".\"version\""},
	SimulationFromMatchID: whereHelpernull_String{field: "\"matches\".\"simulation_from_match_id\""},
	HasLineups:            whereHelperbool{field: "\"matches\".\"has_lineups\""},
	Period:                whereHelperstring{field: "\"matches\".\"period\""},
	Status:                whereHelperstring{field: "\"matches\".\"status\""},
	MatchType:             whereHelperint{field: "\"matches\".\"match_type\""},
	Minute:                whereHelperint{field: "\"matches\".\"minute\""},
	Second:                whereHelperint{field: "\"matches\".\"second\""},
	Rewarded:              whereHelperbool{field: "\"matches\".\"rewarded\""},
	LastSyncedAt:          whereHelpernull_Time{field: "\"matches\".\"last_synced_at\""},
	AwayTeamSelectionID:   whereHelpernull_String{field: "\"matches\".\"away_team_selection_id\""},
	HomeTeamSelectionID:   whereHelpernull_String{field: "\"matches\".\"home_team_selection_id\""},
	MatchDayID:            whereHelpernull_String{field: "\"matches\".\"match_day_id\""},
	EditionID:             whereHelpernull_String{field: "\"matches\".\"edition_id\""},
	Week:                  whereHelperint{field: "\"matches\".\"week\""},
	SportID:               whereHelpernull_String{field: "\"matches\".\"sport_id\""},
	Enabled:               whereHelperbool{field: "\"matches\".\"enabled\""},
}

// MatchRels is where relationship names are stored.
var MatchRels = struct {
	AwayTeam                   string
	Competition                string
	Edition                    string
	HomeTeam                   string
	MatchDay                   string
	Season                     string
	SimulationFromMatch        string
	Sport                      string
	MatchIDAppInboxes          string
	ChatRooms                  string
	Games                      string
	MatchEventProcessors       string
	MatchEventSimulations      string
	MatchEvents                string
	MatchHeadlines             string
	MatchLeaderboards          string
	MatchNotifications         string
	MatchPlayers               string
	MatchRewards               string
	SimulationFromMatchMatches string
	OptaFeedItems              string
	OptaFeeds                  string
	PushNotifications          string
	Transactions               string
}{
	AwayTeam:                   "AwayTeam",
	Competition:                "Competition",
	Edition:                    "Edition",
	HomeTeam:                   "HomeTeam",
	MatchDay:                   "MatchDay",
	Season:                     "Season",
	SimulationFromMatch:        "SimulationFromMatch",
	Sport:                      "Sport",
	MatchIDAppInboxes:          "MatchIDAppInboxes",
	ChatRooms:                  "ChatRooms",
	Games:                      "Games",
	MatchEventProcessors:       "MatchEventProcessors",
	MatchEventSimulations:      "MatchEventSimulations",
	MatchEvents:                "MatchEvents",
	MatchHeadlines:             "MatchHeadlines",
	MatchLeaderboards:          "MatchLeaderboards",
	MatchNotifications:         "MatchNotifications",
	MatchPlayers:               "MatchPlayers",
	MatchRewards:               "MatchRewards",
	SimulationFromMatchMatches: "SimulationFromMatchMatches",
	OptaFeedItems:              "OptaFeedItems",
	OptaFeeds:                  "OptaFeeds",
	PushNotifications:          "PushNotifications",
	Transactions:               "Transactions",
}

// matchR is where relationships are stored.
type matchR struct {
	AwayTeam                   *Team                     `boil:"AwayTeam" json:"AwayTeam" toml:"AwayTeam" yaml:"AwayTeam"`
	Competition                *Competition              `boil:"Competition" json:"Competition" toml:"Competition" yaml:"Competition"`
	Edition                    *CompetitionEdition       `boil:"Edition" json:"Edition" toml:"Edition" yaml:"Edition"`
	HomeTeam                   *Team                     `boil:"HomeTeam" json:"HomeTeam" toml:"HomeTeam" yaml:"HomeTeam"`
	MatchDay                   *MatchDay                 `boil:"MatchDay" json:"MatchDay" toml:"MatchDay" yaml:"MatchDay"`
	Season                     *Season                   `boil:"Season" json:"Season" toml:"Season" yaml:"Season"`
	SimulationFromMatch        *Match                    `boil:"SimulationFromMatch" json:"SimulationFromMatch" toml:"SimulationFromMatch" yaml:"SimulationFromMatch"`
	Sport                      *Sport                    `boil:"Sport" json:"Sport" toml:"Sport" yaml:"Sport"`
	MatchIDAppInboxes          AppInboxSlice             `boil:"MatchIDAppInboxes" json:"MatchIDAppInboxes" toml:"MatchIDAppInboxes" yaml:"MatchIDAppInboxes"`
	ChatRooms                  ChatRoomSlice             `boil:"ChatRooms" json:"ChatRooms" toml:"ChatRooms" yaml:"ChatRooms"`
	Games                      GameSlice                 `boil:"Games" json:"Games" toml:"Games" yaml:"Games"`
	MatchEventProcessors       MatchEventProcessorSlice  `boil:"MatchEventProcessors" json:"MatchEventProcessors" toml:"MatchEventProcessors" yaml:"MatchEventProcessors"`
	MatchEventSimulations      MatchEventSimulationSlice `boil:"MatchEventSimulations" json:"MatchEventSimulations" toml:"MatchEventSimulations" yaml:"MatchEventSimulations"`
	MatchEvents                MatchEventSlice           `boil:"MatchEvents" json:"MatchEvents" toml:"MatchEvents" yaml:"MatchEvents"`
	MatchHeadlines             MatchHeadlineSlice        `boil:"MatchHeadlines" json:"MatchHeadlines" toml:"MatchHeadlines" yaml:"MatchHeadlines"`
	MatchLeaderboards          MatchLeaderboardSlice     `boil:"MatchLeaderboards" json:"MatchLeaderboards" toml:"MatchLeaderboards" yaml:"MatchLeaderboards"`
	MatchNotifications         MatchNotificationSlice    `boil:"MatchNotifications" json:"MatchNotifications" toml:"MatchNotifications" yaml:"MatchNotifications"`
	MatchPlayers               MatchPlayerSlice          `boil:"MatchPlayers" json:"MatchPlayers" toml:"MatchPlayers" yaml:"MatchPlayers"`
	MatchRewards               MatchRewardSlice          `boil:"MatchRewards" json:"MatchRewards" toml:"MatchRewards" yaml:"MatchRewards"`
	SimulationFromMatchMatches MatchSlice                `boil:"SimulationFromMatchMatches" json:"SimulationFromMatchMatches" toml:"SimulationFromMatchMatches" yaml:"SimulationFromMatchMatches"`
	OptaFeedItems              OptaFeedItemSlice         `boil:"OptaFeedItems" json:"OptaFeedItems" toml:"OptaFeedItems" yaml:"OptaFeedItems"`
	OptaFeeds                  OptaFeedSlice             `boil:"OptaFeeds" json:"OptaFeeds" toml:"OptaFeeds" yaml:"OptaFeeds"`
	PushNotifications          PushNotificationSlice     `boil:"PushNotifications" json:"PushNotifications" toml:"PushNotifications" yaml:"PushNotifications"`
	Transactions               TransactionSlice          `boil:"Transactions" json:"Transactions" toml:"Transactions" yaml:"Transactions"`
}

// NewStruct creates a new relationship struct
func (*matchR) NewStruct() *matchR {
	return &matchR{}
}

func (r *matchR) GetAwayTeam() *Team {
	if r == nil {
		return nil
	}
	return r.AwayTeam
}

func (r *matchR) GetCompetition() *Competition {
	if r == nil {
		return nil
	}
	return r.Competition
}

func (r *matchR) GetEdition() *CompetitionEdition {
	if r == nil {
		return nil
	}
	return r.Edition
}

func (r *matchR) GetHomeTeam() *Team {
	if r == nil {
		return nil
	}
	return r.HomeTeam
}

func (r *matchR) GetMatchDay() *MatchDay {
	if r == nil {
		return nil
	}
	return r.MatchDay
}

func (r *matchR) GetSeason() *Season {
	if r == nil {
		return nil
	}
	return r.Season
}

func (r *matchR) GetSimulationFromMatch() *Match {
	if r == nil {
		return nil
	}
	return r.SimulationFromMatch
}

func (r *matchR) GetSport() *Sport {
	if r == nil {
		return nil
	}
	return r.Sport
}

func (r *matchR) GetMatchIDAppInboxes() AppInboxSlice {
	if r == nil {
		return nil
	}
	return r.MatchIDAppInboxes
}

func (r *matchR) GetChatRooms() ChatRoomSlice {
	if r == nil {
		return nil
	}
	return r.ChatRooms
}

func (r *matchR) GetGames() GameSlice {
	if r == nil {
		return nil
	}
	return r.Games
}

func (r *matchR) GetMatchEventProcessors() MatchEventProcessorSlice {
	if r == nil {
		return nil
	}
	return r.MatchEventProcessors
}

func (r *matchR) GetMatchEventSimulations() MatchEventSimulationSlice {
	if r == nil {
		return nil
	}
	return r.MatchEventSimulations
}

func (r *matchR) GetMatchEvents() MatchEventSlice {
	if r == nil {
		return nil
	}
	return r.MatchEvents
}

func (r *matchR) GetMatchHeadlines() MatchHeadlineSlice {
	if r == nil {
		return nil
	}
	return r.MatchHeadlines
}

func (r *matchR) GetMatchLeaderboards() MatchLeaderboardSlice {
	if r == nil {
		return nil
	}
	return r.MatchLeaderboards
}

func (r *matchR) GetMatchNotifications() MatchNotificationSlice {
	if r == nil {
		return nil
	}
	return r.MatchNotifications
}

func (r *matchR) GetMatchPlayers() MatchPlayerSlice {
	if r == nil {
		return nil
	}
	return r.MatchPlayers
}

func (r *matchR) GetMatchRewards() MatchRewardSlice {
	if r == nil {
		return nil
	}
	return r.MatchRewards
}

func (r *matchR) GetSimulationFromMatchMatches() MatchSlice {
	if r == nil {
		return nil
	}
	return r.SimulationFromMatchMatches
}

func (r *matchR) GetOptaFeedItems() OptaFeedItemSlice {
	if r == nil {
		return nil
	}
	return r.OptaFeedItems
}

func (r *matchR) GetOptaFeeds() OptaFeedSlice {
	if r == nil {
		return nil
	}
	return r.OptaFeeds
}

func (r *matchR) GetPushNotifications() PushNotificationSlice {
	if r == nil {
		return nil
	}
	return r.PushNotifications
}

func (r *matchR) GetTransactions() TransactionSlice {
	if r == nil {
		return nil
	}
	return r.Transactions
}

// matchL is where Load methods for each relationship are stored.
type matchL struct{}

var (
	matchAllColumns            = []string{"id", "created_at", "updated_at", "import_id", "match_time", "last_processed_id", "away_team_id", "competition_id", "home_team_id", "season_id", "home_score", "away_score", "match_end", "f_start", "f_end", "s_start", "s_end", "x1_start", "x1_end", "x2_start", "x2_end", "p_start", "p_end", "version", "simulation_from_match_id", "has_lineups", "period", "status", "match_type", "minute", "second", "rewarded", "last_synced_at", "away_team_selection_id", "home_team_selection_id", "match_day_id", "edition_id", "week", "sport_id", "enabled"}
	matchColumnsWithoutDefault = []string{"id", "created_at", "updated_at", "match_time", "away_team_id", "competition_id", "home_team_id", "season_id", "home_score", "away_score", "version", "has_lineups", "period", "status", "match_type", "minute", "second", "rewarded", "week", "enabled"}
	matchColumnsWithDefault    = []string{"import_id", "last_processed_id", "match_end", "f_start", "f_end", "s_start", "s_end", "x1_start", "x1_end", "x2_start", "x2_end", "p_start", "p_end", "simulation_from_match_id", "last_synced_at", "away_team_selection_id", "home_team_selection_id", "match_day_id", "edition_id", "sport_id"}
	matchPrimaryKeyColumns     = []string{"id"}
	matchGeneratedColumns      = []string{}
)

type (
	// MatchSlice is an alias for a slice of pointers to Match.
	// This should almost always be used instead of []Match.
	MatchSlice []*Match

	matchQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	matchType                 = reflect.TypeOf(&Match{})
	matchMapping              = queries.MakeStructMapping(matchType)
	matchPrimaryKeyMapping, _ = queries.BindMapping(matchType, matchMapping, matchPrimaryKeyColumns)
	matchInsertCacheMut       sync.RWMutex
	matchInsertCache          = make(map[string]insertCache)
	matchUpdateCacheMut       sync.RWMutex
	matchUpdateCache          = make(map[string]updateCache)
	matchUpsertCacheMut       sync.RWMutex
	matchUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// One returns a single match record from the query.
func (q matchQuery) One(exec boil.Executor) (*Match, error) {
	o := &Match{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(nil, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "schema: failed to execute a one query for matches")
	}

	return o, nil
}

// All returns all Match records from the query.
func (q matchQuery) All(exec boil.Executor) (MatchSlice, error) {
	var o []*Match

	err := q.Bind(nil, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "schema: failed to assign all query results to Match slice")
	}

	return o, nil
}

// Count returns the count of all Match records in the query.
func (q matchQuery) Count(exec boil.Executor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "schema: failed to count matches rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q matchQuery) Exists(exec boil.Executor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "schema: failed to check if matches exists")
	}

	return count > 0, nil
}

// AwayTeam pointed to by the foreign key.
func (o *Match) AwayTeam(mods ...qm.QueryMod) teamQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.AwayTeamID),
	}

	queryMods = append(queryMods, mods...)

	return Teams(queryMods...)
}

// Competition pointed to by the foreign key.
func (o *Match) Competition(mods ...qm.QueryMod) competitionQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.CompetitionID),
	}

	queryMods = append(queryMods, mods...)

	return Competitions(queryMods...)
}

// Edition pointed to by the foreign key.
func (o *Match) Edition(mods ...qm.QueryMod) competitionEditionQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.EditionID),
	}

	queryMods = append(queryMods, mods...)

	return CompetitionEditions(queryMods...)
}

// HomeTeam pointed to by the foreign key.
func (o *Match) HomeTeam(mods ...qm.QueryMod) teamQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.HomeTeamID),
	}

	queryMods = append(queryMods, mods...)

	return Teams(queryMods...)
}

// MatchDay pointed to by the foreign key.
func (o *Match) MatchDay(mods ...qm.QueryMod) matchDayQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.MatchDayID),
	}

	queryMods = append(queryMods, mods...)

	return MatchDays(queryMods...)
}

// Season pointed to by the foreign key.
func (o *Match) Season(mods ...qm.QueryMod) seasonQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.SeasonID),
	}

	queryMods = append(queryMods, mods...)

	return Seasons(queryMods...)
}

// SimulationFromMatch pointed to by the foreign key.
func (o *Match) SimulationFromMatch(mods ...qm.QueryMod) matchQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.SimulationFromMatchID),
	}

	queryMods = append(queryMods, mods...)

	return Matches(queryMods...)
}

// Sport pointed to by the foreign key.
func (o *Match) Sport(mods ...qm.QueryMod) sportQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.SportID),
	}

	queryMods = append(queryMods, mods...)

	return Sports(queryMods...)
}

// MatchIDAppInboxes retrieves all the app_inbox's AppInboxes with an executor via match_id_id column.
func (o *Match) MatchIDAppInboxes(mods ...qm.QueryMod) appInboxQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"app_inbox\".\"match_id_id\"=?", o.ID),
	)

	return AppInboxes(queryMods...)
}

// ChatRooms retrieves all the chat_room's ChatRooms with an executor.
func (o *Match) ChatRooms(mods ...qm.QueryMod) chatRoomQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"chat_rooms\".\"match_id\"=?", o.ID),
	)

	return ChatRooms(queryMods...)
}

// Games retrieves all the game's Games with an executor.
func (o *Match) Games(mods ...qm.QueryMod) gameQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"games\".\"match_id\"=?", o.ID),
	)

	return Games(queryMods...)
}

// MatchEventProcessors retrieves all the match_event_processor's MatchEventProcessors with an executor.
func (o *Match) MatchEventProcessors(mods ...qm.QueryMod) matchEventProcessorQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"match_event_processors\".\"match_id\"=?", o.ID),
	)

	return MatchEventProcessors(queryMods...)
}

// MatchEventSimulations retrieves all the match_event_simulation's MatchEventSimulations with an executor.
func (o *Match) MatchEventSimulations(mods ...qm.QueryMod) matchEventSimulationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"match_event_simulations\".\"match_id\"=?", o.ID),
	)

	return MatchEventSimulations(queryMods...)
}

// MatchEvents retrieves all the match_event's MatchEvents with an executor.
func (o *Match) MatchEvents(mods ...qm.QueryMod) matchEventQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"match_events\".\"match_id\"=?", o.ID),
	)

	return MatchEvents(queryMods...)
}

// MatchHeadlines retrieves all the match_headline's MatchHeadlines with an executor.
func (o *Match) MatchHeadlines(mods ...qm.QueryMod) matchHeadlineQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"match_headlines\".\"match_id\"=?", o.ID),
	)

	return MatchHeadlines(queryMods...)
}

// MatchLeaderboards retrieves all the match_leaderboard's MatchLeaderboards with an executor.
func (o *Match) MatchLeaderboards(mods ...qm.QueryMod) matchLeaderboardQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"match_leaderboard\".\"match_id\"=?", o.ID),
	)

	return MatchLeaderboards(queryMods...)
}

// MatchNotifications retrieves all the match_notification's MatchNotifications with an executor.
func (o *Match) MatchNotifications(mods ...qm.QueryMod) matchNotificationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"match_notifications\".\"match_id\"=?", o.ID),
	)

	return MatchNotifications(queryMods...)
}

// MatchPlayers retrieves all the match_player's MatchPlayers with an executor.
func (o *Match) MatchPlayers(mods ...qm.QueryMod) matchPlayerQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"match_players\".\"match_id\"=?", o.ID),
	)

	return MatchPlayers(queryMods...)
}

// MatchRewards retrieves all the match_reward's MatchRewards with an executor.
func (o *Match) MatchRewards(mods ...qm.QueryMod) matchRewardQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"match_rewards\".\"match_id\"=?", o.ID),
	)

	return MatchRewards(queryMods...)
}

// SimulationFromMatchMatches retrieves all the match's Matches with an executor via simulation_from_match_id column.
func (o *Match) SimulationFromMatchMatches(mods ...qm.QueryMod) matchQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"matches\".\"simulation_from_match_id\"=?", o.ID),
	)

	return Matches(queryMods...)
}

// OptaFeedItems retrieves all the opta_feed_item's OptaFeedItems with an executor.
func (o *Match) OptaFeedItems(mods ...qm.QueryMod) optaFeedItemQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"opta_feed_items\".\"match_id\"=?", o.ID),
	)

	return OptaFeedItems(queryMods...)
}

// OptaFeeds retrieves all the opta_feed's OptaFeeds with an executor.
func (o *Match) OptaFeeds(mods ...qm.QueryMod) optaFeedQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"opta_feeds\".\"match_id\"=?", o.ID),
	)

	return OptaFeeds(queryMods...)
}

// PushNotifications retrieves all the push_notification's PushNotifications with an executor.
func (o *Match) PushNotifications(mods ...qm.QueryMod) pushNotificationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"push_notifications\".\"match_id\"=?", o.ID),
	)

	return PushNotifications(queryMods...)
}

// Transactions retrieves all the transaction's Transactions with an executor.
func (o *Match) Transactions(mods ...qm.QueryMod) transactionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"transactions\".\"match_id\"=?", o.ID),
	)

	return Transactions(queryMods...)
}

// LoadAwayTeam allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (matchL) LoadAwayTeam(e boil.Executor, singular bool, maybeMatch interface{}, mods queries.Applicator) error {
	var slice []*Match
	var object *Match

	if singular {
		var ok bool
		object, ok = maybeMatch.(*Match)
		if !ok {
			object = new(Match)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMatch))
			}
		}
	} else {
		s, ok := maybeMatch.(*[]*Match)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMatch))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &matchR{}
		}
		args[object.AwayTeamID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &matchR{}
			}

			args[obj.AwayTeamID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`teams`),
		qm.WhereIn(`teams.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Team")
	}

	var resultSlice []*Team
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Team")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for teams")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for teams")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.AwayTeam = foreign
		if foreign.R == nil {
			foreign.R = &teamR{}
		}
		foreign.R.AwayTeamMatches = append(foreign.R.AwayTeamMatches, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.AwayTeamID == foreign.ID {
				local.R.AwayTeam = foreign
				if foreign.R == nil {
					foreign.R = &teamR{}
				}
				foreign.R.AwayTeamMatches = append(foreign.R.AwayTeamMatches, local)
				break
			}
		}
	}

	return nil
}

// LoadCompetition allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (matchL) LoadCompetition(e boil.Executor, singular bool, maybeMatch interface{}, mods queries.Applicator) error {
	var slice []*Match
	var object *Match

	if singular {
		var ok bool
		object, ok = maybeMatch.(*Match)
		if !ok {
			object = new(Match)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMatch))
			}
		}
	} else {
		s, ok := maybeMatch.(*[]*Match)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMatch))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &matchR{}
		}
		args[object.CompetitionID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &matchR{}
			}

			args[obj.CompetitionID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`competitions`),
		qm.WhereIn(`competitions.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Competition")
	}

	var resultSlice []*Competition
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Competition")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for competitions")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for competitions")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Competition = foreign
		if foreign.R == nil {
			foreign.R = &competitionR{}
		}
		foreign.R.Matches = append(foreign.R.Matches, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.CompetitionID == foreign.ID {
				local.R.Competition = foreign
				if foreign.R == nil {
					foreign.R = &competitionR{}
				}
				foreign.R.Matches = append(foreign.R.Matches, local)
				break
			}
		}
	}

	return nil
}

// LoadEdition allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (matchL) LoadEdition(e boil.Executor, singular bool, maybeMatch interface{}, mods queries.Applicator) error {
	var slice []*Match
	var object *Match

	if singular {
		var ok bool
		object, ok = maybeMatch.(*Match)
		if !ok {
			object = new(Match)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMatch))
			}
		}
	} else {
		s, ok := maybeMatch.(*[]*Match)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMatch))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &matchR{}
		}
		if !queries.IsNil(object.EditionID) {
			args[object.EditionID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &matchR{}
			}

			if !queries.IsNil(obj.EditionID) {
				args[obj.EditionID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`competition_editions`),
		qm.WhereIn(`competition_editions.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load CompetitionEdition")
	}

	var resultSlice []*CompetitionEdition
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice CompetitionEdition")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for competition_editions")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for competition_editions")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Edition = foreign
		if foreign.R == nil {
			foreign.R = &competitionEditionR{}
		}
		foreign.R.EditionMatches = append(foreign.R.EditionMatches, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.EditionID, foreign.ID) {
				local.R.Edition = foreign
				if foreign.R == nil {
					foreign.R = &competitionEditionR{}
				}
				foreign.R.EditionMatches = append(foreign.R.EditionMatches, local)
				break
			}
		}
	}

	return nil
}

// LoadHomeTeam allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (matchL) LoadHomeTeam(e boil.Executor, singular bool, maybeMatch interface{}, mods queries.Applicator) error {
	var slice []*Match
	var object *Match

	if singular {
		var ok bool
		object, ok = maybeMatch.(*Match)
		if !ok {
			object = new(Match)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMatch))
			}
		}
	} else {
		s, ok := maybeMatch.(*[]*Match)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMatch))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &matchR{}
		}
		args[object.HomeTeamID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &matchR{}
			}

			args[obj.HomeTeamID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`teams`),
		qm.WhereIn(`teams.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Team")
	}

	var resultSlice []*Team
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Team")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for teams")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for teams")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.HomeTeam = foreign
		if foreign.R == nil {
			foreign.R = &teamR{}
		}
		foreign.R.HomeTeamMatches = append(foreign.R.HomeTeamMatches, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.HomeTeamID == foreign.ID {
				local.R.HomeTeam = foreign
				if foreign.R == nil {
					foreign.R = &teamR{}
				}
				foreign.R.HomeTeamMatches = append(foreign.R.HomeTeamMatches, local)
				break
			}
		}
	}

	return nil
}

// LoadMatchDay allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (matchL) LoadMatchDay(e boil.Executor, singular bool, maybeMatch interface{}, mods queries.Applicator) error {
	var slice []*Match
	var object *Match

	if singular {
		var ok bool
		object, ok = maybeMatch.(*Match)
		if !ok {
			object = new(Match)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMatch))
			}
		}
	} else {
		s, ok := maybeMatch.(*[]*Match)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMatch))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &matchR{}
		}
		if !queries.IsNil(object.MatchDayID) {
			args[object.MatchDayID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &matchR{}
			}

			if !queries.IsNil(obj.MatchDayID) {
				args[obj.MatchDayID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`match_days`),
		qm.WhereIn(`match_days.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load MatchDay")
	}

	var resultSlice []*MatchDay
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice MatchDay")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for match_days")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for match_days")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.MatchDay = foreign
		if foreign.R == nil {
			foreign.R = &matchDayR{}
		}
		foreign.R.Matches = append(foreign.R.Matches, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.MatchDayID, foreign.ID) {
				local.R.MatchDay = foreign
				if foreign.R == nil {
					foreign.R = &matchDayR{}
				}
				foreign.R.Matches = append(foreign.R.Matches, local)
				break
			}
		}
	}

	return nil
}

// LoadSeason allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (matchL) LoadSeason(e boil.Executor, singular bool, maybeMatch interface{}, mods queries.Applicator) error {
	var slice []*Match
	var object *Match

	if singular {
		var ok bool
		object, ok = maybeMatch.(*Match)
		if !ok {
			object = new(Match)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMatch))
			}
		}
	} else {
		s, ok := maybeMatch.(*[]*Match)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMatch))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &matchR{}
		}
		args[object.SeasonID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &matchR{}
			}

			args[obj.SeasonID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`seasons`),
		qm.WhereIn(`seasons.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Season")
	}

	var resultSlice []*Season
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Season")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for seasons")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for seasons")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Season = foreign
		if foreign.R == nil {
			foreign.R = &seasonR{}
		}
		foreign.R.Matches = append(foreign.R.Matches, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.SeasonID == foreign.ID {
				local.R.Season = foreign
				if foreign.R == nil {
					foreign.R = &seasonR{}
				}
				foreign.R.Matches = append(foreign.R.Matches, local)
				break
			}
		}
	}

	return nil
}

// LoadSimulationFromMatch allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (matchL) LoadSimulationFromMatch(e boil.Executor, singular bool, maybeMatch interface{}, mods queries.Applicator) error {
	var slice []*Match
	var object *Match

	if singular {
		var ok bool
		object, ok = maybeMatch.(*Match)
		if !ok {
			object = new(Match)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMatch))
			}
		}
	} else {
		s, ok := maybeMatch.(*[]*Match)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMatch))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &matchR{}
		}
		if !queries.IsNil(object.SimulationFromMatchID) {
			args[object.SimulationFromMatchID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &matchR{}
			}

			if !queries.IsNil(obj.SimulationFromMatchID) {
				args[obj.SimulationFromMatchID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`matches`),
		qm.WhereIn(`matches.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Match")
	}

	var resultSlice []*Match
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Match")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for matches")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for matches")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.SimulationFromMatch = foreign
		if foreign.R == nil {
			foreign.R = &matchR{}
		}
		foreign.R.SimulationFromMatchMatches = append(foreign.R.SimulationFromMatchMatches, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.SimulationFromMatchID, foreign.ID) {
				local.R.SimulationFromMatch = foreign
				if foreign.R == nil {
					foreign.R = &matchR{}
				}
				foreign.R.SimulationFromMatchMatches = append(foreign.R.SimulationFromMatchMatches, local)
				break
			}
		}
	}

	return nil
}

// LoadSport allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (matchL) LoadSport(e boil.Executor, singular bool, maybeMatch interface{}, mods queries.Applicator) error {
	var slice []*Match
	var object *Match

	if singular {
		var ok bool
		object, ok = maybeMatch.(*Match)
		if !ok {
			object = new(Match)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMatch))
			}
		}
	} else {
		s, ok := maybeMatch.(*[]*Match)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMatch))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &matchR{}
		}
		if !queries.IsNil(object.SportID) {
			args[object.SportID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &matchR{}
			}

			if !queries.IsNil(obj.SportID) {
				args[obj.SportID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`sports`),
		qm.WhereIn(`sports.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Sport")
	}

	var resultSlice []*Sport
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Sport")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for sports")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for sports")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Sport = foreign
		if foreign.R == nil {
			foreign.R = &sportR{}
		}
		foreign.R.Matches = append(foreign.R.Matches, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.SportID, foreign.ID) {
				local.R.Sport = foreign
				if foreign.R == nil {
					foreign.R = &sportR{}
				}
				foreign.R.Matches = append(foreign.R.Matches, local)
				break
			}
		}
	}

	return nil
}

// LoadMatchIDAppInboxes allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (matchL) LoadMatchIDAppInboxes(e boil.Executor, singular bool, maybeMatch interface{}, mods queries.Applicator) error {
	var slice []*Match
	var object *Match

	if singular {
		var ok bool
		object, ok = maybeMatch.(*Match)
		if !ok {
			object = new(Match)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMatch))
			}
		}
	} else {
		s, ok := maybeMatch.(*[]*Match)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMatch))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &matchR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &matchR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`app_inbox`),
		qm.WhereIn(`app_inbox.match_id_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load app_inbox")
	}

	var resultSlice []*AppInbox
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice app_inbox")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on app_inbox")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for app_inbox")
	}

	if singular {
		object.R.MatchIDAppInboxes = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &appInboxR{}
			}
			foreign.R.MatchID = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.MatchIDID) {
				local.R.MatchIDAppInboxes = append(local.R.MatchIDAppInboxes, foreign)
				if foreign.R == nil {
					foreign.R = &appInboxR{}
				}
				foreign.R.MatchID = local
				break
			}
		}
	}

	return nil
}

// LoadChatRooms allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (matchL) LoadChatRooms(e boil.Executor, singular bool, maybeMatch interface{}, mods queries.Applicator) error {
	var slice []*Match
	var object *Match

	if singular {
		var ok bool
		object, ok = maybeMatch.(*Match)
		if !ok {
			object = new(Match)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMatch))
			}
		}
	} else {
		s, ok := maybeMatch.(*[]*Match)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMatch))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &matchR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &matchR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`chat_rooms`),
		qm.WhereIn(`chat_rooms.match_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load chat_rooms")
	}

	var resultSlice []*ChatRoom
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice chat_rooms")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on chat_rooms")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for chat_rooms")
	}

	if singular {
		object.R.ChatRooms = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &chatRoomR{}
			}
			foreign.R.Match = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.MatchID) {
				local.R.ChatRooms = append(local.R.ChatRooms, foreign)
				if foreign.R == nil {
					foreign.R = &chatRoomR{}
				}
				foreign.R.Match = local
				break
			}
		}
	}

	return nil
}

// LoadGames allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (matchL) LoadGames(e boil.Executor, singular bool, maybeMatch interface{}, mods queries.Applicator) error {
	var slice []*Match
	var object *Match

	if singular {
		var ok bool
		object, ok = maybeMatch.(*Match)
		if !ok {
			object = new(Match)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMatch))
			}
		}
	} else {
		s, ok := maybeMatch.(*[]*Match)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMatch))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &matchR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &matchR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`games`),
		qm.WhereIn(`games.match_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load games")
	}

	var resultSlice []*Game
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice games")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on games")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for games")
	}

	if singular {
		object.R.Games = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &gameR{}
			}
			foreign.R.Match = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.MatchID {
				local.R.Games = append(local.R.Games, foreign)
				if foreign.R == nil {
					foreign.R = &gameR{}
				}
				foreign.R.Match = local
				break
			}
		}
	}

	return nil
}

// LoadMatchEventProcessors allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (matchL) LoadMatchEventProcessors(e boil.Executor, singular bool, maybeMatch interface{}, mods queries.Applicator) error {
	var slice []*Match
	var object *Match

	if singular {
		var ok bool
		object, ok = maybeMatch.(*Match)
		if !ok {
			object = new(Match)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMatch))
			}
		}
	} else {
		s, ok := maybeMatch.(*[]*Match)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMatch))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &matchR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &matchR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`match_event_processors`),
		qm.WhereIn(`match_event_processors.match_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load match_event_processors")
	}

	var resultSlice []*MatchEventProcessor
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice match_event_processors")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on match_event_processors")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for match_event_processors")
	}

	if singular {
		object.R.MatchEventProcessors = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &matchEventProcessorR{}
			}
			foreign.R.Match = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.MatchID {
				local.R.MatchEventProcessors = append(local.R.MatchEventProcessors, foreign)
				if foreign.R == nil {
					foreign.R = &matchEventProcessorR{}
				}
				foreign.R.Match = local
				break
			}
		}
	}

	return nil
}

// LoadMatchEventSimulations allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (matchL) LoadMatchEventSimulations(e boil.Executor, singular bool, maybeMatch interface{}, mods queries.Applicator) error {
	var slice []*Match
	var object *Match

	if singular {
		var ok bool
		object, ok = maybeMatch.(*Match)
		if !ok {
			object = new(Match)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMatch))
			}
		}
	} else {
		s, ok := maybeMatch.(*[]*Match)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMatch))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &matchR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &matchR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`match_event_simulations`),
		qm.WhereIn(`match_event_simulations.match_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load match_event_simulations")
	}

	var resultSlice []*MatchEventSimulation
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice match_event_simulations")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on match_event_simulations")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for match_event_simulations")
	}

	if singular {
		object.R.MatchEventSimulations = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &matchEventSimulationR{}
			}
			foreign.R.Match = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.MatchID {
				local.R.MatchEventSimulations = append(local.R.MatchEventSimulations, foreign)
				if foreign.R == nil {
					foreign.R = &matchEventSimulationR{}
				}
				foreign.R.Match = local
				break
			}
		}
	}

	return nil
}

// LoadMatchEvents allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (matchL) LoadMatchEvents(e boil.Executor, singular bool, maybeMatch interface{}, mods queries.Applicator) error {
	var slice []*Match
	var object *Match

	if singular {
		var ok bool
		object, ok = maybeMatch.(*Match)
		if !ok {
			object = new(Match)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMatch))
			}
		}
	} else {
		s, ok := maybeMatch.(*[]*Match)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMatch))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &matchR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &matchR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`match_events`),
		qm.WhereIn(`match_events.match_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load match_events")
	}

	var resultSlice []*MatchEvent
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice match_events")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on match_events")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for match_events")
	}

	if singular {
		object.R.MatchEvents = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &matchEventR{}
			}
			foreign.R.Match = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.MatchID {
				local.R.MatchEvents = append(local.R.MatchEvents, foreign)
				if foreign.R == nil {
					foreign.R = &matchEventR{}
				}
				foreign.R.Match = local
				break
			}
		}
	}

	return nil
}

// LoadMatchHeadlines allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (matchL) LoadMatchHeadlines(e boil.Executor, singular bool, maybeMatch interface{}, mods queries.Applicator) error {
	var slice []*Match
	var object *Match

	if singular {
		var ok bool
		object, ok = maybeMatch.(*Match)
		if !ok {
			object = new(Match)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMatch))
			}
		}
	} else {
		s, ok := maybeMatch.(*[]*Match)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMatch))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &matchR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &matchR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`match_headlines`),
		qm.WhereIn(`match_headlines.match_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load match_headlines")
	}

	var resultSlice []*MatchHeadline
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice match_headlines")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on match_headlines")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for match_headlines")
	}

	if singular {
		object.R.MatchHeadlines = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &matchHeadlineR{}
			}
			foreign.R.Match = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.MatchID {
				local.R.MatchHeadlines = append(local.R.MatchHeadlines, foreign)
				if foreign.R == nil {
					foreign.R = &matchHeadlineR{}
				}
				foreign.R.Match = local
				break
			}
		}
	}

	return nil
}

// LoadMatchLeaderboards allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (matchL) LoadMatchLeaderboards(e boil.Executor, singular bool, maybeMatch interface{}, mods queries.Applicator) error {
	var slice []*Match
	var object *Match

	if singular {
		var ok bool
		object, ok = maybeMatch.(*Match)
		if !ok {
			object = new(Match)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMatch))
			}
		}
	} else {
		s, ok := maybeMatch.(*[]*Match)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMatch))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &matchR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &matchR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`match_leaderboard`),
		qm.WhereIn(`match_leaderboard.match_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load match_leaderboard")
	}

	var resultSlice []*MatchLeaderboard
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice match_leaderboard")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on match_leaderboard")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for match_leaderboard")
	}

	if singular {
		object.R.MatchLeaderboards = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &matchLeaderboardR{}
			}
			foreign.R.Match = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.MatchID {
				local.R.MatchLeaderboards = append(local.R.MatchLeaderboards, foreign)
				if foreign.R == nil {
					foreign.R = &matchLeaderboardR{}
				}
				foreign.R.Match = local
				break
			}
		}
	}

	return nil
}

// LoadMatchNotifications allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (matchL) LoadMatchNotifications(e boil.Executor, singular bool, maybeMatch interface{}, mods queries.Applicator) error {
	var slice []*Match
	var object *Match

	if singular {
		var ok bool
		object, ok = maybeMatch.(*Match)
		if !ok {
			object = new(Match)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMatch))
			}
		}
	} else {
		s, ok := maybeMatch.(*[]*Match)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMatch))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &matchR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &matchR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`match_notifications`),
		qm.WhereIn(`match_notifications.match_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load match_notifications")
	}

	var resultSlice []*MatchNotification
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice match_notifications")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on match_notifications")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for match_notifications")
	}

	if singular {
		object.R.MatchNotifications = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &matchNotificationR{}
			}
			foreign.R.Match = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.MatchID {
				local.R.MatchNotifications = append(local.R.MatchNotifications, foreign)
				if foreign.R == nil {
					foreign.R = &matchNotificationR{}
				}
				foreign.R.Match = local
				break
			}
		}
	}

	return nil
}

// LoadMatchPlayers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (matchL) LoadMatchPlayers(e boil.Executor, singular bool, maybeMatch interface{}, mods queries.Applicator) error {
	var slice []*Match
	var object *Match

	if singular {
		var ok bool
		object, ok = maybeMatch.(*Match)
		if !ok {
			object = new(Match)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMatch))
			}
		}
	} else {
		s, ok := maybeMatch.(*[]*Match)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMatch))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &matchR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &matchR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`match_players`),
		qm.WhereIn(`match_players.match_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load match_players")
	}

	var resultSlice []*MatchPlayer
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice match_players")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on match_players")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for match_players")
	}

	if singular {
		object.R.MatchPlayers = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &matchPlayerR{}
			}
			foreign.R.Match = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.MatchID {
				local.R.MatchPlayers = append(local.R.MatchPlayers, foreign)
				if foreign.R == nil {
					foreign.R = &matchPlayerR{}
				}
				foreign.R.Match = local
				break
			}
		}
	}

	return nil
}

// LoadMatchRewards allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (matchL) LoadMatchRewards(e boil.Executor, singular bool, maybeMatch interface{}, mods queries.Applicator) error {
	var slice []*Match
	var object *Match

	if singular {
		var ok bool
		object, ok = maybeMatch.(*Match)
		if !ok {
			object = new(Match)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMatch))
			}
		}
	} else {
		s, ok := maybeMatch.(*[]*Match)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMatch))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &matchR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &matchR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`match_rewards`),
		qm.WhereIn(`match_rewards.match_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load match_rewards")
	}

	var resultSlice []*MatchReward
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice match_rewards")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on match_rewards")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for match_rewards")
	}

	if singular {
		object.R.MatchRewards = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &matchRewardR{}
			}
			foreign.R.Match = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.MatchID {
				local.R.MatchRewards = append(local.R.MatchRewards, foreign)
				if foreign.R == nil {
					foreign.R = &matchRewardR{}
				}
				foreign.R.Match = local
				break
			}
		}
	}

	return nil
}

// LoadSimulationFromMatchMatches allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (matchL) LoadSimulationFromMatchMatches(e boil.Executor, singular bool, maybeMatch interface{}, mods queries.Applicator) error {
	var slice []*Match
	var object *Match

	if singular {
		var ok bool
		object, ok = maybeMatch.(*Match)
		if !ok {
			object = new(Match)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMatch))
			}
		}
	} else {
		s, ok := maybeMatch.(*[]*Match)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMatch))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &matchR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &matchR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`matches`),
		qm.WhereIn(`matches.simulation_from_match_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load matches")
	}

	var resultSlice []*Match
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice matches")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on matches")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for matches")
	}

	if singular {
		object.R.SimulationFromMatchMatches = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &matchR{}
			}
			foreign.R.SimulationFromMatch = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.SimulationFromMatchID) {
				local.R.SimulationFromMatchMatches = append(local.R.SimulationFromMatchMatches, foreign)
				if foreign.R == nil {
					foreign.R = &matchR{}
				}
				foreign.R.SimulationFromMatch = local
				break
			}
		}
	}

	return nil
}

// LoadOptaFeedItems allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (matchL) LoadOptaFeedItems(e boil.Executor, singular bool, maybeMatch interface{}, mods queries.Applicator) error {
	var slice []*Match
	var object *Match

	if singular {
		var ok bool
		object, ok = maybeMatch.(*Match)
		if !ok {
			object = new(Match)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMatch))
			}
		}
	} else {
		s, ok := maybeMatch.(*[]*Match)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMatch))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &matchR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &matchR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`opta_feed_items`),
		qm.WhereIn(`opta_feed_items.match_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load opta_feed_items")
	}

	var resultSlice []*OptaFeedItem
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice opta_feed_items")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on opta_feed_items")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for opta_feed_items")
	}

	if singular {
		object.R.OptaFeedItems = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &optaFeedItemR{}
			}
			foreign.R.Match = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.MatchID {
				local.R.OptaFeedItems = append(local.R.OptaFeedItems, foreign)
				if foreign.R == nil {
					foreign.R = &optaFeedItemR{}
				}
				foreign.R.Match = local
				break
			}
		}
	}

	return nil
}

// LoadOptaFeeds allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (matchL) LoadOptaFeeds(e boil.Executor, singular bool, maybeMatch interface{}, mods queries.Applicator) error {
	var slice []*Match
	var object *Match

	if singular {
		var ok bool
		object, ok = maybeMatch.(*Match)
		if !ok {
			object = new(Match)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMatch))
			}
		}
	} else {
		s, ok := maybeMatch.(*[]*Match)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMatch))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &matchR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &matchR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`opta_feeds`),
		qm.WhereIn(`opta_feeds.match_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load opta_feeds")
	}

	var resultSlice []*OptaFeed
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice opta_feeds")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on opta_feeds")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for opta_feeds")
	}

	if singular {
		object.R.OptaFeeds = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &optaFeedR{}
			}
			foreign.R.Match = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.MatchID) {
				local.R.OptaFeeds = append(local.R.OptaFeeds, foreign)
				if foreign.R == nil {
					foreign.R = &optaFeedR{}
				}
				foreign.R.Match = local
				break
			}
		}
	}

	return nil
}

// LoadPushNotifications allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (matchL) LoadPushNotifications(e boil.Executor, singular bool, maybeMatch interface{}, mods queries.Applicator) error {
	var slice []*Match
	var object *Match

	if singular {
		var ok bool
		object, ok = maybeMatch.(*Match)
		if !ok {
			object = new(Match)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMatch))
			}
		}
	} else {
		s, ok := maybeMatch.(*[]*Match)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMatch))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &matchR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &matchR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`push_notifications`),
		qm.WhereIn(`push_notifications.match_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load push_notifications")
	}

	var resultSlice []*PushNotification
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice push_notifications")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on push_notifications")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for push_notifications")
	}

	if singular {
		object.R.PushNotifications = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &pushNotificationR{}
			}
			foreign.R.Match = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.MatchID) {
				local.R.PushNotifications = append(local.R.PushNotifications, foreign)
				if foreign.R == nil {
					foreign.R = &pushNotificationR{}
				}
				foreign.R.Match = local
				break
			}
		}
	}

	return nil
}

// LoadTransactions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (matchL) LoadTransactions(e boil.Executor, singular bool, maybeMatch interface{}, mods queries.Applicator) error {
	var slice []*Match
	var object *Match

	if singular {
		var ok bool
		object, ok = maybeMatch.(*Match)
		if !ok {
			object = new(Match)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeMatch))
			}
		}
	} else {
		s, ok := maybeMatch.(*[]*Match)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeMatch)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeMatch))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &matchR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &matchR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`transactions`),
		qm.WhereIn(`transactions.match_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load transactions")
	}

	var resultSlice []*Transaction
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice transactions")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on transactions")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for transactions")
	}

	if singular {
		object.R.Transactions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &transactionR{}
			}
			foreign.R.Match = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.MatchID) {
				local.R.Transactions = append(local.R.Transactions, foreign)
				if foreign.R == nil {
					foreign.R = &transactionR{}
				}
				foreign.R.Match = local
				break
			}
		}
	}

	return nil
}

// SetAwayTeam of the match to the related item.
// Sets o.R.AwayTeam to related.
// Adds o to related.R.AwayTeamMatches.
func (o *Match) SetAwayTeam(exec boil.Executor, insert bool, related *Team) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"matches\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"away_team_id"}),
		strmangle.WhereClause("\"", "\"", 2, matchPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.AwayTeamID = related.ID
	if o.R == nil {
		o.R = &matchR{
			AwayTeam: related,
		}
	} else {
		o.R.AwayTeam = related
	}

	if related.R == nil {
		related.R = &teamR{
			AwayTeamMatches: MatchSlice{o},
		}
	} else {
		related.R.AwayTeamMatches = append(related.R.AwayTeamMatches, o)
	}

	return nil
}

// SetCompetition of the match to the related item.
// Sets o.R.Competition to related.
// Adds o to related.R.Matches.
func (o *Match) SetCompetition(exec boil.Executor, insert bool, related *Competition) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"matches\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"competition_id"}),
		strmangle.WhereClause("\"", "\"", 2, matchPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.CompetitionID = related.ID
	if o.R == nil {
		o.R = &matchR{
			Competition: related,
		}
	} else {
		o.R.Competition = related
	}

	if related.R == nil {
		related.R = &competitionR{
			Matches: MatchSlice{o},
		}
	} else {
		related.R.Matches = append(related.R.Matches, o)
	}

	return nil
}

// SetEdition of the match to the related item.
// Sets o.R.Edition to related.
// Adds o to related.R.EditionMatches.
func (o *Match) SetEdition(exec boil.Executor, insert bool, related *CompetitionEdition) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"matches\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"edition_id"}),
		strmangle.WhereClause("\"", "\"", 2, matchPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.EditionID, related.ID)
	if o.R == nil {
		o.R = &matchR{
			Edition: related,
		}
	} else {
		o.R.Edition = related
	}

	if related.R == nil {
		related.R = &competitionEditionR{
			EditionMatches: MatchSlice{o},
		}
	} else {
		related.R.EditionMatches = append(related.R.EditionMatches, o)
	}

	return nil
}

// RemoveEdition relationship.
// Sets o.R.Edition to nil.
// Removes o from all passed in related items' relationships struct.
func (o *Match) RemoveEdition(exec boil.Executor, related *CompetitionEdition) error {
	var err error

	queries.SetScanner(&o.EditionID, nil)
	if _, err = o.Update(exec, boil.Whitelist("edition_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Edition = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.EditionMatches {
		if queries.Equal(o.EditionID, ri.EditionID) {
			continue
		}

		ln := len(related.R.EditionMatches)
		if ln > 1 && i < ln-1 {
			related.R.EditionMatches[i] = related.R.EditionMatches[ln-1]
		}
		related.R.EditionMatches = related.R.EditionMatches[:ln-1]
		break
	}
	return nil
}

// SetHomeTeam of the match to the related item.
// Sets o.R.HomeTeam to related.
// Adds o to related.R.HomeTeamMatches.
func (o *Match) SetHomeTeam(exec boil.Executor, insert bool, related *Team) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"matches\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"home_team_id"}),
		strmangle.WhereClause("\"", "\"", 2, matchPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.HomeTeamID = related.ID
	if o.R == nil {
		o.R = &matchR{
			HomeTeam: related,
		}
	} else {
		o.R.HomeTeam = related
	}

	if related.R == nil {
		related.R = &teamR{
			HomeTeamMatches: MatchSlice{o},
		}
	} else {
		related.R.HomeTeamMatches = append(related.R.HomeTeamMatches, o)
	}

	return nil
}

// SetMatchDay of the match to the related item.
// Sets o.R.MatchDay to related.
// Adds o to related.R.Matches.
func (o *Match) SetMatchDay(exec boil.Executor, insert bool, related *MatchDay) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"matches\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"match_day_id"}),
		strmangle.WhereClause("\"", "\"", 2, matchPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.MatchDayID, related.ID)
	if o.R == nil {
		o.R = &matchR{
			MatchDay: related,
		}
	} else {
		o.R.MatchDay = related
	}

	if related.R == nil {
		related.R = &matchDayR{
			Matches: MatchSlice{o},
		}
	} else {
		related.R.Matches = append(related.R.Matches, o)
	}

	return nil
}

// RemoveMatchDay relationship.
// Sets o.R.MatchDay to nil.
// Removes o from all passed in related items' relationships struct.
func (o *Match) RemoveMatchDay(exec boil.Executor, related *MatchDay) error {
	var err error

	queries.SetScanner(&o.MatchDayID, nil)
	if _, err = o.Update(exec, boil.Whitelist("match_day_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.MatchDay = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Matches {
		if queries.Equal(o.MatchDayID, ri.MatchDayID) {
			continue
		}

		ln := len(related.R.Matches)
		if ln > 1 && i < ln-1 {
			related.R.Matches[i] = related.R.Matches[ln-1]
		}
		related.R.Matches = related.R.Matches[:ln-1]
		break
	}
	return nil
}

// SetSeason of the match to the related item.
// Sets o.R.Season to related.
// Adds o to related.R.Matches.
func (o *Match) SetSeason(exec boil.Executor, insert bool, related *Season) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"matches\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"season_id"}),
		strmangle.WhereClause("\"", "\"", 2, matchPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.SeasonID = related.ID
	if o.R == nil {
		o.R = &matchR{
			Season: related,
		}
	} else {
		o.R.Season = related
	}

	if related.R == nil {
		related.R = &seasonR{
			Matches: MatchSlice{o},
		}
	} else {
		related.R.Matches = append(related.R.Matches, o)
	}

	return nil
}

// SetSimulationFromMatch of the match to the related item.
// Sets o.R.SimulationFromMatch to related.
// Adds o to related.R.SimulationFromMatchMatches.
func (o *Match) SetSimulationFromMatch(exec boil.Executor, insert bool, related *Match) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"matches\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"simulation_from_match_id"}),
		strmangle.WhereClause("\"", "\"", 2, matchPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.SimulationFromMatchID, related.ID)
	if o.R == nil {
		o.R = &matchR{
			SimulationFromMatch: related,
		}
	} else {
		o.R.SimulationFromMatch = related
	}

	if related.R == nil {
		related.R = &matchR{
			SimulationFromMatchMatches: MatchSlice{o},
		}
	} else {
		related.R.SimulationFromMatchMatches = append(related.R.SimulationFromMatchMatches, o)
	}

	return nil
}

// RemoveSimulationFromMatch relationship.
// Sets o.R.SimulationFromMatch to nil.
// Removes o from all passed in related items' relationships struct.
func (o *Match) RemoveSimulationFromMatch(exec boil.Executor, related *Match) error {
	var err error

	queries.SetScanner(&o.SimulationFromMatchID, nil)
	if _, err = o.Update(exec, boil.Whitelist("simulation_from_match_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.SimulationFromMatch = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.SimulationFromMatchMatches {
		if queries.Equal(o.SimulationFromMatchID, ri.SimulationFromMatchID) {
			continue
		}

		ln := len(related.R.SimulationFromMatchMatches)
		if ln > 1 && i < ln-1 {
			related.R.SimulationFromMatchMatches[i] = related.R.SimulationFromMatchMatches[ln-1]
		}
		related.R.SimulationFromMatchMatches = related.R.SimulationFromMatchMatches[:ln-1]
		break
	}
	return nil
}

// SetSport of the match to the related item.
// Sets o.R.Sport to related.
// Adds o to related.R.Matches.
func (o *Match) SetSport(exec boil.Executor, insert bool, related *Sport) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"matches\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"sport_id"}),
		strmangle.WhereClause("\"", "\"", 2, matchPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.SportID, related.ID)
	if o.R == nil {
		o.R = &matchR{
			Sport: related,
		}
	} else {
		o.R.Sport = related
	}

	if related.R == nil {
		related.R = &sportR{
			Matches: MatchSlice{o},
		}
	} else {
		related.R.Matches = append(related.R.Matches, o)
	}

	return nil
}

// RemoveSport relationship.
// Sets o.R.Sport to nil.
// Removes o from all passed in related items' relationships struct.
func (o *Match) RemoveSport(exec boil.Executor, related *Sport) error {
	var err error

	queries.SetScanner(&o.SportID, nil)
	if _, err = o.Update(exec, boil.Whitelist("sport_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Sport = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Matches {
		if queries.Equal(o.SportID, ri.SportID) {
			continue
		}

		ln := len(related.R.Matches)
		if ln > 1 && i < ln-1 {
			related.R.Matches[i] = related.R.Matches[ln-1]
		}
		related.R.Matches = related.R.Matches[:ln-1]
		break
	}
	return nil
}

// AddMatchIDAppInboxes adds the given related objects to the existing relationships
// of the match, optionally inserting them as new records.
// Appends related to o.R.MatchIDAppInboxes.
// Sets related.R.MatchID appropriately.
func (o *Match) AddMatchIDAppInboxes(exec boil.Executor, insert bool, related ...*AppInbox) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.MatchIDID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"app_inbox\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"match_id_id"}),
				strmangle.WhereClause("\"", "\"", 2, appInboxPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.MatchIDID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &matchR{
			MatchIDAppInboxes: related,
		}
	} else {
		o.R.MatchIDAppInboxes = append(o.R.MatchIDAppInboxes, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &appInboxR{
				MatchID: o,
			}
		} else {
			rel.R.MatchID = o
		}
	}
	return nil
}

// SetMatchIDAppInboxes removes all previously related items of the
// match replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.MatchID's MatchIDAppInboxes accordingly.
// Replaces o.R.MatchIDAppInboxes with related.
// Sets related.R.MatchID's MatchIDAppInboxes accordingly.
func (o *Match) SetMatchIDAppInboxes(exec boil.Executor, insert bool, related ...*AppInbox) error {
	query := "update \"app_inbox\" set \"match_id_id\" = null where \"match_id_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.MatchIDAppInboxes {
			queries.SetScanner(&rel.MatchIDID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.MatchID = nil
		}
		o.R.MatchIDAppInboxes = nil
	}

	return o.AddMatchIDAppInboxes(exec, insert, related...)
}

// RemoveMatchIDAppInboxes relationships from objects passed in.
// Removes related items from R.MatchIDAppInboxes (uses pointer comparison, removal does not keep order)
// Sets related.R.MatchID.
func (o *Match) RemoveMatchIDAppInboxes(exec boil.Executor, related ...*AppInbox) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.MatchIDID, nil)
		if rel.R != nil {
			rel.R.MatchID = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("match_id_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.MatchIDAppInboxes {
			if rel != ri {
				continue
			}

			ln := len(o.R.MatchIDAppInboxes)
			if ln > 1 && i < ln-1 {
				o.R.MatchIDAppInboxes[i] = o.R.MatchIDAppInboxes[ln-1]
			}
			o.R.MatchIDAppInboxes = o.R.MatchIDAppInboxes[:ln-1]
			break
		}
	}

	return nil
}

// AddChatRooms adds the given related objects to the existing relationships
// of the match, optionally inserting them as new records.
// Appends related to o.R.ChatRooms.
// Sets related.R.Match appropriately.
func (o *Match) AddChatRooms(exec boil.Executor, insert bool, related ...*ChatRoom) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.MatchID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"chat_rooms\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"match_id"}),
				strmangle.WhereClause("\"", "\"", 2, chatRoomPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.MatchID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &matchR{
			ChatRooms: related,
		}
	} else {
		o.R.ChatRooms = append(o.R.ChatRooms, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &chatRoomR{
				Match: o,
			}
		} else {
			rel.R.Match = o
		}
	}
	return nil
}

// SetChatRooms removes all previously related items of the
// match replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Match's ChatRooms accordingly.
// Replaces o.R.ChatRooms with related.
// Sets related.R.Match's ChatRooms accordingly.
func (o *Match) SetChatRooms(exec boil.Executor, insert bool, related ...*ChatRoom) error {
	query := "update \"chat_rooms\" set \"match_id\" = null where \"match_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.ChatRooms {
			queries.SetScanner(&rel.MatchID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Match = nil
		}
		o.R.ChatRooms = nil
	}

	return o.AddChatRooms(exec, insert, related...)
}

// RemoveChatRooms relationships from objects passed in.
// Removes related items from R.ChatRooms (uses pointer comparison, removal does not keep order)
// Sets related.R.Match.
func (o *Match) RemoveChatRooms(exec boil.Executor, related ...*ChatRoom) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.MatchID, nil)
		if rel.R != nil {
			rel.R.Match = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("match_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ChatRooms {
			if rel != ri {
				continue
			}

			ln := len(o.R.ChatRooms)
			if ln > 1 && i < ln-1 {
				o.R.ChatRooms[i] = o.R.ChatRooms[ln-1]
			}
			o.R.ChatRooms = o.R.ChatRooms[:ln-1]
			break
		}
	}

	return nil
}

// AddGames adds the given related objects to the existing relationships
// of the match, optionally inserting them as new records.
// Appends related to o.R.Games.
// Sets related.R.Match appropriately.
func (o *Match) AddGames(exec boil.Executor, insert bool, related ...*Game) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.MatchID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"games\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"match_id"}),
				strmangle.WhereClause("\"", "\"", 2, gamePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.MatchID = o.ID
		}
	}

	if o.R == nil {
		o.R = &matchR{
			Games: related,
		}
	} else {
		o.R.Games = append(o.R.Games, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &gameR{
				Match: o,
			}
		} else {
			rel.R.Match = o
		}
	}
	return nil
}

// AddMatchEventProcessors adds the given related objects to the existing relationships
// of the match, optionally inserting them as new records.
// Appends related to o.R.MatchEventProcessors.
// Sets related.R.Match appropriately.
func (o *Match) AddMatchEventProcessors(exec boil.Executor, insert bool, related ...*MatchEventProcessor) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.MatchID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"match_event_processors\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"match_id"}),
				strmangle.WhereClause("\"", "\"", 2, matchEventProcessorPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.MatchID = o.ID
		}
	}

	if o.R == nil {
		o.R = &matchR{
			MatchEventProcessors: related,
		}
	} else {
		o.R.MatchEventProcessors = append(o.R.MatchEventProcessors, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &matchEventProcessorR{
				Match: o,
			}
		} else {
			rel.R.Match = o
		}
	}
	return nil
}

// AddMatchEventSimulations adds the given related objects to the existing relationships
// of the match, optionally inserting them as new records.
// Appends related to o.R.MatchEventSimulations.
// Sets related.R.Match appropriately.
func (o *Match) AddMatchEventSimulations(exec boil.Executor, insert bool, related ...*MatchEventSimulation) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.MatchID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"match_event_simulations\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"match_id"}),
				strmangle.WhereClause("\"", "\"", 2, matchEventSimulationPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.MatchID = o.ID
		}
	}

	if o.R == nil {
		o.R = &matchR{
			MatchEventSimulations: related,
		}
	} else {
		o.R.MatchEventSimulations = append(o.R.MatchEventSimulations, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &matchEventSimulationR{
				Match: o,
			}
		} else {
			rel.R.Match = o
		}
	}
	return nil
}

// AddMatchEvents adds the given related objects to the existing relationships
// of the match, optionally inserting them as new records.
// Appends related to o.R.MatchEvents.
// Sets related.R.Match appropriately.
func (o *Match) AddMatchEvents(exec boil.Executor, insert bool, related ...*MatchEvent) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.MatchID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"match_events\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"match_id"}),
				strmangle.WhereClause("\"", "\"", 2, matchEventPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.MatchID = o.ID
		}
	}

	if o.R == nil {
		o.R = &matchR{
			MatchEvents: related,
		}
	} else {
		o.R.MatchEvents = append(o.R.MatchEvents, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &matchEventR{
				Match: o,
			}
		} else {
			rel.R.Match = o
		}
	}
	return nil
}

// AddMatchHeadlines adds the given related objects to the existing relationships
// of the match, optionally inserting them as new records.
// Appends related to o.R.MatchHeadlines.
// Sets related.R.Match appropriately.
func (o *Match) AddMatchHeadlines(exec boil.Executor, insert bool, related ...*MatchHeadline) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.MatchID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"match_headlines\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"match_id"}),
				strmangle.WhereClause("\"", "\"", 2, matchHeadlinePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.MatchID = o.ID
		}
	}

	if o.R == nil {
		o.R = &matchR{
			MatchHeadlines: related,
		}
	} else {
		o.R.MatchHeadlines = append(o.R.MatchHeadlines, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &matchHeadlineR{
				Match: o,
			}
		} else {
			rel.R.Match = o
		}
	}
	return nil
}

// AddMatchLeaderboards adds the given related objects to the existing relationships
// of the match, optionally inserting them as new records.
// Appends related to o.R.MatchLeaderboards.
// Sets related.R.Match appropriately.
func (o *Match) AddMatchLeaderboards(exec boil.Executor, insert bool, related ...*MatchLeaderboard) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.MatchID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"match_leaderboard\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"match_id"}),
				strmangle.WhereClause("\"", "\"", 2, matchLeaderboardPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.MatchID = o.ID
		}
	}

	if o.R == nil {
		o.R = &matchR{
			MatchLeaderboards: related,
		}
	} else {
		o.R.MatchLeaderboards = append(o.R.MatchLeaderboards, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &matchLeaderboardR{
				Match: o,
			}
		} else {
			rel.R.Match = o
		}
	}
	return nil
}

// AddMatchNotifications adds the given related objects to the existing relationships
// of the match, optionally inserting them as new records.
// Appends related to o.R.MatchNotifications.
// Sets related.R.Match appropriately.
func (o *Match) AddMatchNotifications(exec boil.Executor, insert bool, related ...*MatchNotification) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.MatchID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"match_notifications\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"match_id"}),
				strmangle.WhereClause("\"", "\"", 2, matchNotificationPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.MatchID = o.ID
		}
	}

	if o.R == nil {
		o.R = &matchR{
			MatchNotifications: related,
		}
	} else {
		o.R.MatchNotifications = append(o.R.MatchNotifications, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &matchNotificationR{
				Match: o,
			}
		} else {
			rel.R.Match = o
		}
	}
	return nil
}

// AddMatchPlayers adds the given related objects to the existing relationships
// of the match, optionally inserting them as new records.
// Appends related to o.R.MatchPlayers.
// Sets related.R.Match appropriately.
func (o *Match) AddMatchPlayers(exec boil.Executor, insert bool, related ...*MatchPlayer) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.MatchID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"match_players\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"match_id"}),
				strmangle.WhereClause("\"", "\"", 2, matchPlayerPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.MatchID = o.ID
		}
	}

	if o.R == nil {
		o.R = &matchR{
			MatchPlayers: related,
		}
	} else {
		o.R.MatchPlayers = append(o.R.MatchPlayers, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &matchPlayerR{
				Match: o,
			}
		} else {
			rel.R.Match = o
		}
	}
	return nil
}

// AddMatchRewards adds the given related objects to the existing relationships
// of the match, optionally inserting them as new records.
// Appends related to o.R.MatchRewards.
// Sets related.R.Match appropriately.
func (o *Match) AddMatchRewards(exec boil.Executor, insert bool, related ...*MatchReward) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.MatchID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"match_rewards\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"match_id"}),
				strmangle.WhereClause("\"", "\"", 2, matchRewardPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.MatchID = o.ID
		}
	}

	if o.R == nil {
		o.R = &matchR{
			MatchRewards: related,
		}
	} else {
		o.R.MatchRewards = append(o.R.MatchRewards, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &matchRewardR{
				Match: o,
			}
		} else {
			rel.R.Match = o
		}
	}
	return nil
}

// AddSimulationFromMatchMatches adds the given related objects to the existing relationships
// of the match, optionally inserting them as new records.
// Appends related to o.R.SimulationFromMatchMatches.
// Sets related.R.SimulationFromMatch appropriately.
func (o *Match) AddSimulationFromMatchMatches(exec boil.Executor, insert bool, related ...*Match) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.SimulationFromMatchID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"matches\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"simulation_from_match_id"}),
				strmangle.WhereClause("\"", "\"", 2, matchPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.SimulationFromMatchID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &matchR{
			SimulationFromMatchMatches: related,
		}
	} else {
		o.R.SimulationFromMatchMatches = append(o.R.SimulationFromMatchMatches, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &matchR{
				SimulationFromMatch: o,
			}
		} else {
			rel.R.SimulationFromMatch = o
		}
	}
	return nil
}

// SetSimulationFromMatchMatches removes all previously related items of the
// match replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.SimulationFromMatch's SimulationFromMatchMatches accordingly.
// Replaces o.R.SimulationFromMatchMatches with related.
// Sets related.R.SimulationFromMatch's SimulationFromMatchMatches accordingly.
func (o *Match) SetSimulationFromMatchMatches(exec boil.Executor, insert bool, related ...*Match) error {
	query := "update \"matches\" set \"simulation_from_match_id\" = null where \"simulation_from_match_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.SimulationFromMatchMatches {
			queries.SetScanner(&rel.SimulationFromMatchID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.SimulationFromMatch = nil
		}
		o.R.SimulationFromMatchMatches = nil
	}

	return o.AddSimulationFromMatchMatches(exec, insert, related...)
}

// RemoveSimulationFromMatchMatches relationships from objects passed in.
// Removes related items from R.SimulationFromMatchMatches (uses pointer comparison, removal does not keep order)
// Sets related.R.SimulationFromMatch.
func (o *Match) RemoveSimulationFromMatchMatches(exec boil.Executor, related ...*Match) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.SimulationFromMatchID, nil)
		if rel.R != nil {
			rel.R.SimulationFromMatch = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("simulation_from_match_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.SimulationFromMatchMatches {
			if rel != ri {
				continue
			}

			ln := len(o.R.SimulationFromMatchMatches)
			if ln > 1 && i < ln-1 {
				o.R.SimulationFromMatchMatches[i] = o.R.SimulationFromMatchMatches[ln-1]
			}
			o.R.SimulationFromMatchMatches = o.R.SimulationFromMatchMatches[:ln-1]
			break
		}
	}

	return nil
}

// AddOptaFeedItems adds the given related objects to the existing relationships
// of the match, optionally inserting them as new records.
// Appends related to o.R.OptaFeedItems.
// Sets related.R.Match appropriately.
func (o *Match) AddOptaFeedItems(exec boil.Executor, insert bool, related ...*OptaFeedItem) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.MatchID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"opta_feed_items\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"match_id"}),
				strmangle.WhereClause("\"", "\"", 2, optaFeedItemPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.MatchID = o.ID
		}
	}

	if o.R == nil {
		o.R = &matchR{
			OptaFeedItems: related,
		}
	} else {
		o.R.OptaFeedItems = append(o.R.OptaFeedItems, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &optaFeedItemR{
				Match: o,
			}
		} else {
			rel.R.Match = o
		}
	}
	return nil
}

// AddOptaFeeds adds the given related objects to the existing relationships
// of the match, optionally inserting them as new records.
// Appends related to o.R.OptaFeeds.
// Sets related.R.Match appropriately.
func (o *Match) AddOptaFeeds(exec boil.Executor, insert bool, related ...*OptaFeed) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.MatchID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"opta_feeds\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"match_id"}),
				strmangle.WhereClause("\"", "\"", 2, optaFeedPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.MatchID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &matchR{
			OptaFeeds: related,
		}
	} else {
		o.R.OptaFeeds = append(o.R.OptaFeeds, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &optaFeedR{
				Match: o,
			}
		} else {
			rel.R.Match = o
		}
	}
	return nil
}

// SetOptaFeeds removes all previously related items of the
// match replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Match's OptaFeeds accordingly.
// Replaces o.R.OptaFeeds with related.
// Sets related.R.Match's OptaFeeds accordingly.
func (o *Match) SetOptaFeeds(exec boil.Executor, insert bool, related ...*OptaFeed) error {
	query := "update \"opta_feeds\" set \"match_id\" = null where \"match_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.OptaFeeds {
			queries.SetScanner(&rel.MatchID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Match = nil
		}
		o.R.OptaFeeds = nil
	}

	return o.AddOptaFeeds(exec, insert, related...)
}

// RemoveOptaFeeds relationships from objects passed in.
// Removes related items from R.OptaFeeds (uses pointer comparison, removal does not keep order)
// Sets related.R.Match.
func (o *Match) RemoveOptaFeeds(exec boil.Executor, related ...*OptaFeed) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.MatchID, nil)
		if rel.R != nil {
			rel.R.Match = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("match_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.OptaFeeds {
			if rel != ri {
				continue
			}

			ln := len(o.R.OptaFeeds)
			if ln > 1 && i < ln-1 {
				o.R.OptaFeeds[i] = o.R.OptaFeeds[ln-1]
			}
			o.R.OptaFeeds = o.R.OptaFeeds[:ln-1]
			break
		}
	}

	return nil
}

// AddPushNotifications adds the given related objects to the existing relationships
// of the match, optionally inserting them as new records.
// Appends related to o.R.PushNotifications.
// Sets related.R.Match appropriately.
func (o *Match) AddPushNotifications(exec boil.Executor, insert bool, related ...*PushNotification) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.MatchID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"push_notifications\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"match_id"}),
				strmangle.WhereClause("\"", "\"", 2, pushNotificationPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.MatchID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &matchR{
			PushNotifications: related,
		}
	} else {
		o.R.PushNotifications = append(o.R.PushNotifications, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &pushNotificationR{
				Match: o,
			}
		} else {
			rel.R.Match = o
		}
	}
	return nil
}

// SetPushNotifications removes all previously related items of the
// match replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Match's PushNotifications accordingly.
// Replaces o.R.PushNotifications with related.
// Sets related.R.Match's PushNotifications accordingly.
func (o *Match) SetPushNotifications(exec boil.Executor, insert bool, related ...*PushNotification) error {
	query := "update \"push_notifications\" set \"match_id\" = null where \"match_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.PushNotifications {
			queries.SetScanner(&rel.MatchID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Match = nil
		}
		o.R.PushNotifications = nil
	}

	return o.AddPushNotifications(exec, insert, related...)
}

// RemovePushNotifications relationships from objects passed in.
// Removes related items from R.PushNotifications (uses pointer comparison, removal does not keep order)
// Sets related.R.Match.
func (o *Match) RemovePushNotifications(exec boil.Executor, related ...*PushNotification) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.MatchID, nil)
		if rel.R != nil {
			rel.R.Match = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("match_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.PushNotifications {
			if rel != ri {
				continue
			}

			ln := len(o.R.PushNotifications)
			if ln > 1 && i < ln-1 {
				o.R.PushNotifications[i] = o.R.PushNotifications[ln-1]
			}
			o.R.PushNotifications = o.R.PushNotifications[:ln-1]
			break
		}
	}

	return nil
}

// AddTransactions adds the given related objects to the existing relationships
// of the match, optionally inserting them as new records.
// Appends related to o.R.Transactions.
// Sets related.R.Match appropriately.
func (o *Match) AddTransactions(exec boil.Executor, insert bool, related ...*Transaction) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.MatchID, o.ID)
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"transactions\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"match_id"}),
				strmangle.WhereClause("\"", "\"", 2, transactionPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.MatchID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &matchR{
			Transactions: related,
		}
	} else {
		o.R.Transactions = append(o.R.Transactions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &transactionR{
				Match: o,
			}
		} else {
			rel.R.Match = o
		}
	}
	return nil
}

// SetTransactions removes all previously related items of the
// match replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Match's Transactions accordingly.
// Replaces o.R.Transactions with related.
// Sets related.R.Match's Transactions accordingly.
func (o *Match) SetTransactions(exec boil.Executor, insert bool, related ...*Transaction) error {
	query := "update \"transactions\" set \"match_id\" = null where \"match_id\" = $1"
	values := []interface{}{o.ID}
	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	_, err := exec.Exec(query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.Transactions {
			queries.SetScanner(&rel.MatchID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Match = nil
		}
		o.R.Transactions = nil
	}

	return o.AddTransactions(exec, insert, related...)
}

// RemoveTransactions relationships from objects passed in.
// Removes related items from R.Transactions (uses pointer comparison, removal does not keep order)
// Sets related.R.Match.
func (o *Match) RemoveTransactions(exec boil.Executor, related ...*Transaction) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.MatchID, nil)
		if rel.R != nil {
			rel.R.Match = nil
		}
		if _, err = rel.Update(exec, boil.Whitelist("match_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.Transactions {
			if rel != ri {
				continue
			}

			ln := len(o.R.Transactions)
			if ln > 1 && i < ln-1 {
				o.R.Transactions[i] = o.R.Transactions[ln-1]
			}
			o.R.Transactions = o.R.Transactions[:ln-1]
			break
		}
	}

	return nil
}

// Matches retrieves all the records using an executor.
func Matches(mods ...qm.QueryMod) matchQuery {
	mods = append(mods, qm.From("\"matches\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"matches\".*"})
	}

	return matchQuery{q}
}

// FindMatch retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindMatch(exec boil.Executor, iD string, selectCols ...string) (*Match, error) {
	matchObj := &Match{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"matches\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(nil, exec, matchObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "schema: unable to select from matches")
	}

	return matchObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Match) Insert(exec boil.Executor, columns boil.Columns) error {
	if o == nil {
		return errors.New("schema: no matches provided for insertion")
	}

	var err error
	currTime := time.Now().In(boil.GetLocation())

	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}
	if o.UpdatedAt.IsZero() {
		o.UpdatedAt = currTime
	}

	nzDefaults := queries.NonZeroDefaultSet(matchColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	matchInsertCacheMut.RLock()
	cache, cached := matchInsertCache[key]
	matchInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			matchAllColumns,
			matchColumnsWithDefault,
			matchColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(matchType, matchMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(matchType, matchMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"matches\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"matches\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "schema: unable to insert into matches")
	}

	if !cached {
		matchInsertCacheMut.Lock()
		matchInsertCache[key] = cache
		matchInsertCacheMut.Unlock()
	}

	return nil
}

// Update uses an executor to update the Match.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Match) Update(exec boil.Executor, columns boil.Columns) (int64, error) {
	currTime := time.Now().In(boil.GetLocation())

	o.UpdatedAt = currTime

	var err error
	key := makeCacheKey(columns, nil)
	matchUpdateCacheMut.RLock()
	cache, cached := matchUpdateCache[key]
	matchUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			matchAllColumns,
			matchPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("schema: unable to update matches, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"matches\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, matchPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(matchType, matchMapping, append(wl, matchPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	var result sql.Result
	result, err = exec.Exec(cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to update matches row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "schema: failed to get rows affected by update for matches")
	}

	if !cached {
		matchUpdateCacheMut.Lock()
		matchUpdateCache[key] = cache
		matchUpdateCacheMut.Unlock()
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values.
func (q matchQuery) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to update all for matches")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to retrieve rows affected for matches")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o MatchSlice) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("schema: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), matchPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"matches\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, matchPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to update all in match slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to retrieve rows affected all in update all match")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Match) Upsert(exec boil.Executor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("schema: no matches provided for upsert")
	}
	currTime := time.Now().In(boil.GetLocation())

	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}
	o.UpdatedAt = currTime

	nzDefaults := queries.NonZeroDefaultSet(matchColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	matchUpsertCacheMut.RLock()
	cache, cached := matchUpsertCache[key]
	matchUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			matchAllColumns,
			matchColumnsWithDefault,
			matchColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			matchAllColumns,
			matchPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("schema: unable to upsert matches, could not build update column list")
		}

		ret := strmangle.SetComplement(matchAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(matchPrimaryKeyColumns) == 0 {
				return errors.New("schema: unable to upsert matches, could not build conflict column list")
			}

			conflict = make([]string, len(matchPrimaryKeyColumns))
			copy(conflict, matchPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"matches\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(matchType, matchMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(matchType, matchMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "schema: unable to upsert matches")
	}

	if !cached {
		matchUpsertCacheMut.Lock()
		matchUpsertCache[key] = cache
		matchUpsertCacheMut.Unlock()
	}

	return nil
}

// Delete deletes a single Match record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Match) Delete(exec boil.Executor) (int64, error) {
	if o == nil {
		return 0, errors.New("schema: no Match provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), matchPrimaryKeyMapping)
	sql := "DELETE FROM \"matches\" WHERE \"id\"=$1"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to delete from matches")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "schema: failed to get rows affected by delete for matches")
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q matchQuery) DeleteAll(exec boil.Executor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("schema: no matchQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to delete all from matches")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "schema: failed to get rows affected by deleteall for matches")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o MatchSlice) DeleteAll(exec boil.Executor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), matchPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"matches\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, matchPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to delete all from match slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "schema: failed to get rows affected by deleteall for matches")
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Match) Reload(exec boil.Executor) error {
	ret, err := FindMatch(exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *MatchSlice) ReloadAll(exec boil.Executor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := MatchSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), matchPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"matches\".* FROM \"matches\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, matchPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(nil, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "schema: unable to reload all in MatchSlice")
	}

	*o = slice

	return nil
}

// MatchExists checks if the Match row exists.
func MatchExists(exec boil.Executor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"matches\" where \"id\"=$1 limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}
	row := exec.QueryRow(sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "schema: unable to check if matches exists")
	}

	return exists, nil
}

// Exists checks if the Match row exists.
func (o *Match) Exists(exec boil.Executor) (bool, error) {
	return MatchExists(exec, o.ID)
}
