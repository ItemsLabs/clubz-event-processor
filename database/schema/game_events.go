// Code generated by SQLBoiler 4.16.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package schema

import (
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// GameEvent is an object representing the database table.
type GameEvent struct {
	ID              string      `boil:"id" json:"id" toml:"id" yaml:"id"`
	CreatedAt       time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	Minute          int         `boil:"minute" json:"minute" toml:"minute" yaml:"minute"`
	Second          int         `boil:"second" json:"second" toml:"second" yaml:"second"`
	Type            int         `boil:"type" json:"type" toml:"type" yaml:"type"`
	Score           float64     `boil:"score" json:"score" toml:"score" yaml:"score"`
	GameID          string      `boil:"game_id" json:"game_id" toml:"game_id" yaml:"game_id"`
	GamePickID      string      `boil:"game_pick_id" json:"game_pick_id" toml:"game_pick_id" yaml:"game_pick_id"`
	PlayerID        string      `boil:"player_id" json:"player_id" toml:"player_id" yaml:"player_id"`
	TeamID          string      `boil:"team_id" json:"team_id" toml:"team_id" yaml:"team_id"`
	InitialScore    float64     `boil:"initial_score" json:"initial_score" toml:"initial_score" yaml:"initial_score"`
	PowerupID       null.String `boil:"powerup_id" json:"powerup_id,omitempty" toml:"powerup_id" yaml:"powerup_id,omitempty"`
	MatchEventID    null.Int    `boil:"match_event_id" json:"match_event_id,omitempty" toml:"match_event_id" yaml:"match_event_id,omitempty"`
	BoostMultiplier float64     `boil:"boost_multiplier" json:"boost_multiplier" toml:"boost_multiplier" yaml:"boost_multiplier"`
	NFTImage        null.String `boil:"nft_image" json:"nft_image,omitempty" toml:"nft_image" yaml:"nft_image,omitempty"`
	NFTMultiplier   float64     `boil:"nft_multiplier" json:"nft_multiplier" toml:"nft_multiplier" yaml:"nft_multiplier"`

	R *gameEventR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L gameEventL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var GameEventColumns = struct {
	ID              string
	CreatedAt       string
	Minute          string
	Second          string
	Type            string
	Score           string
	GameID          string
	GamePickID      string
	PlayerID        string
	TeamID          string
	InitialScore    string
	PowerupID       string
	MatchEventID    string
	BoostMultiplier string
	NFTImage        string
	NFTMultiplier   string
}{
	ID:              "id",
	CreatedAt:       "created_at",
	Minute:          "minute",
	Second:          "second",
	Type:            "type",
	Score:           "score",
	GameID:          "game_id",
	GamePickID:      "game_pick_id",
	PlayerID:        "player_id",
	TeamID:          "team_id",
	InitialScore:    "initial_score",
	PowerupID:       "powerup_id",
	MatchEventID:    "match_event_id",
	BoostMultiplier: "boost_multiplier",
	NFTImage:        "nft_image",
	NFTMultiplier:   "nft_multiplier",
}

var GameEventTableColumns = struct {
	ID              string
	CreatedAt       string
	Minute          string
	Second          string
	Type            string
	Score           string
	GameID          string
	GamePickID      string
	PlayerID        string
	TeamID          string
	InitialScore    string
	PowerupID       string
	MatchEventID    string
	BoostMultiplier string
	NFTImage        string
	NFTMultiplier   string
}{
	ID:              "game_events.id",
	CreatedAt:       "game_events.created_at",
	Minute:          "game_events.minute",
	Second:          "game_events.second",
	Type:            "game_events.type",
	Score:           "game_events.score",
	GameID:          "game_events.game_id",
	GamePickID:      "game_events.game_pick_id",
	PlayerID:        "game_events.player_id",
	TeamID:          "game_events.team_id",
	InitialScore:    "game_events.initial_score",
	PowerupID:       "game_events.powerup_id",
	MatchEventID:    "game_events.match_event_id",
	BoostMultiplier: "game_events.boost_multiplier",
	NFTImage:        "game_events.nft_image",
	NFTMultiplier:   "game_events.nft_multiplier",
}

// Generated where

var GameEventWhere = struct {
	ID              whereHelperstring
	CreatedAt       whereHelpertime_Time
	Minute          whereHelperint
	Second          whereHelperint
	Type            whereHelperint
	Score           whereHelperfloat64
	GameID          whereHelperstring
	GamePickID      whereHelperstring
	PlayerID        whereHelperstring
	TeamID          whereHelperstring
	InitialScore    whereHelperfloat64
	PowerupID       whereHelpernull_String
	MatchEventID    whereHelpernull_Int
	BoostMultiplier whereHelperfloat64
	NFTImage        whereHelpernull_String
	NFTMultiplier   whereHelperfloat64
}{
	ID:              whereHelperstring{field: "\"game_events\".\"id\""},
	CreatedAt:       whereHelpertime_Time{field: "\"game_events\".\"created_at\""},
	Minute:          whereHelperint{field: "\"game_events\".\"minute\""},
	Second:          whereHelperint{field: "\"game_events\".\"second\""},
	Type:            whereHelperint{field: "\"game_events\".\"type\""},
	Score:           whereHelperfloat64{field: "\"game_events\".\"score\""},
	GameID:          whereHelperstring{field: "\"game_events\".\"game_id\""},
	GamePickID:      whereHelperstring{field: "\"game_events\".\"game_pick_id\""},
	PlayerID:        whereHelperstring{field: "\"game_events\".\"player_id\""},
	TeamID:          whereHelperstring{field: "\"game_events\".\"team_id\""},
	InitialScore:    whereHelperfloat64{field: "\"game_events\".\"initial_score\""},
	PowerupID:       whereHelpernull_String{field: "\"game_events\".\"powerup_id\""},
	MatchEventID:    whereHelpernull_Int{field: "\"game_events\".\"match_event_id\""},
	BoostMultiplier: whereHelperfloat64{field: "\"game_events\".\"boost_multiplier\""},
	NFTImage:        whereHelpernull_String{field: "\"game_events\".\"nft_image\""},
	NFTMultiplier:   whereHelperfloat64{field: "\"game_events\".\"nft_multiplier\""},
}

// GameEventRels is where relationship names are stored.
var GameEventRels = struct {
	Game       string
	GamePick   string
	MatchEvent string
	Player     string
	Powerup    string
	Team       string
}{
	Game:       "Game",
	GamePick:   "GamePick",
	MatchEvent: "MatchEvent",
	Player:     "Player",
	Powerup:    "Powerup",
	Team:       "Team",
}

// gameEventR is where relationships are stored.
type gameEventR struct {
	Game       *Game        `boil:"Game" json:"Game" toml:"Game" yaml:"Game"`
	GamePick   *GamePick    `boil:"GamePick" json:"GamePick" toml:"GamePick" yaml:"GamePick"`
	MatchEvent *MatchEvent  `boil:"MatchEvent" json:"MatchEvent" toml:"MatchEvent" yaml:"MatchEvent"`
	Player     *Player      `boil:"Player" json:"Player" toml:"Player" yaml:"Player"`
	Powerup    *GamePowerup `boil:"Powerup" json:"Powerup" toml:"Powerup" yaml:"Powerup"`
	Team       *Team        `boil:"Team" json:"Team" toml:"Team" yaml:"Team"`
}

// NewStruct creates a new relationship struct
func (*gameEventR) NewStruct() *gameEventR {
	return &gameEventR{}
}

func (r *gameEventR) GetGame() *Game {
	if r == nil {
		return nil
	}
	return r.Game
}

func (r *gameEventR) GetGamePick() *GamePick {
	if r == nil {
		return nil
	}
	return r.GamePick
}

func (r *gameEventR) GetMatchEvent() *MatchEvent {
	if r == nil {
		return nil
	}
	return r.MatchEvent
}

func (r *gameEventR) GetPlayer() *Player {
	if r == nil {
		return nil
	}
	return r.Player
}

func (r *gameEventR) GetPowerup() *GamePowerup {
	if r == nil {
		return nil
	}
	return r.Powerup
}

func (r *gameEventR) GetTeam() *Team {
	if r == nil {
		return nil
	}
	return r.Team
}

// gameEventL is where Load methods for each relationship are stored.
type gameEventL struct{}

var (
	gameEventAllColumns            = []string{"id", "created_at", "minute", "second", "type", "score", "game_id", "game_pick_id", "player_id", "team_id", "initial_score", "powerup_id", "match_event_id", "boost_multiplier", "nft_image", "nft_multiplier"}
	gameEventColumnsWithoutDefault = []string{"id", "created_at", "minute", "second", "type", "score", "game_id", "game_pick_id", "player_id", "team_id", "initial_score", "boost_multiplier", "nft_multiplier"}
	gameEventColumnsWithDefault    = []string{"powerup_id", "match_event_id", "nft_image"}
	gameEventPrimaryKeyColumns     = []string{"id"}
	gameEventGeneratedColumns      = []string{}
)

type (
	// GameEventSlice is an alias for a slice of pointers to GameEvent.
	// This should almost always be used instead of []GameEvent.
	GameEventSlice []*GameEvent

	gameEventQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	gameEventType                 = reflect.TypeOf(&GameEvent{})
	gameEventMapping              = queries.MakeStructMapping(gameEventType)
	gameEventPrimaryKeyMapping, _ = queries.BindMapping(gameEventType, gameEventMapping, gameEventPrimaryKeyColumns)
	gameEventInsertCacheMut       sync.RWMutex
	gameEventInsertCache          = make(map[string]insertCache)
	gameEventUpdateCacheMut       sync.RWMutex
	gameEventUpdateCache          = make(map[string]updateCache)
	gameEventUpsertCacheMut       sync.RWMutex
	gameEventUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// One returns a single gameEvent record from the query.
func (q gameEventQuery) One(exec boil.Executor) (*GameEvent, error) {
	o := &GameEvent{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(nil, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "schema: failed to execute a one query for game_events")
	}

	return o, nil
}

// All returns all GameEvent records from the query.
func (q gameEventQuery) All(exec boil.Executor) (GameEventSlice, error) {
	var o []*GameEvent

	err := q.Bind(nil, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "schema: failed to assign all query results to GameEvent slice")
	}

	return o, nil
}

// Count returns the count of all GameEvent records in the query.
func (q gameEventQuery) Count(exec boil.Executor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "schema: failed to count game_events rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q gameEventQuery) Exists(exec boil.Executor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "schema: failed to check if game_events exists")
	}

	return count > 0, nil
}

// Game pointed to by the foreign key.
func (o *GameEvent) Game(mods ...qm.QueryMod) gameQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.GameID),
	}

	queryMods = append(queryMods, mods...)

	return Games(queryMods...)
}

// GamePick pointed to by the foreign key.
func (o *GameEvent) GamePick(mods ...qm.QueryMod) gamePickQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.GamePickID),
	}

	queryMods = append(queryMods, mods...)

	return GamePicks(queryMods...)
}

// MatchEvent pointed to by the foreign key.
func (o *GameEvent) MatchEvent(mods ...qm.QueryMod) matchEventQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.MatchEventID),
	}

	queryMods = append(queryMods, mods...)

	return MatchEvents(queryMods...)
}

// Player pointed to by the foreign key.
func (o *GameEvent) Player(mods ...qm.QueryMod) playerQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.PlayerID),
	}

	queryMods = append(queryMods, mods...)

	return Players(queryMods...)
}

// Powerup pointed to by the foreign key.
func (o *GameEvent) Powerup(mods ...qm.QueryMod) gamePowerupQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.PowerupID),
	}

	queryMods = append(queryMods, mods...)

	return GamePowerups(queryMods...)
}

// Team pointed to by the foreign key.
func (o *GameEvent) Team(mods ...qm.QueryMod) teamQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.TeamID),
	}

	queryMods = append(queryMods, mods...)

	return Teams(queryMods...)
}

// LoadGame allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (gameEventL) LoadGame(e boil.Executor, singular bool, maybeGameEvent interface{}, mods queries.Applicator) error {
	var slice []*GameEvent
	var object *GameEvent

	if singular {
		var ok bool
		object, ok = maybeGameEvent.(*GameEvent)
		if !ok {
			object = new(GameEvent)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeGameEvent)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeGameEvent))
			}
		}
	} else {
		s, ok := maybeGameEvent.(*[]*GameEvent)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeGameEvent)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeGameEvent))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &gameEventR{}
		}
		args[object.GameID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &gameEventR{}
			}

			args[obj.GameID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`games`),
		qm.WhereIn(`games.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Game")
	}

	var resultSlice []*Game
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Game")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for games")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for games")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Game = foreign
		if foreign.R == nil {
			foreign.R = &gameR{}
		}
		foreign.R.GameEvents = append(foreign.R.GameEvents, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.GameID == foreign.ID {
				local.R.Game = foreign
				if foreign.R == nil {
					foreign.R = &gameR{}
				}
				foreign.R.GameEvents = append(foreign.R.GameEvents, local)
				break
			}
		}
	}

	return nil
}

// LoadGamePick allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (gameEventL) LoadGamePick(e boil.Executor, singular bool, maybeGameEvent interface{}, mods queries.Applicator) error {
	var slice []*GameEvent
	var object *GameEvent

	if singular {
		var ok bool
		object, ok = maybeGameEvent.(*GameEvent)
		if !ok {
			object = new(GameEvent)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeGameEvent)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeGameEvent))
			}
		}
	} else {
		s, ok := maybeGameEvent.(*[]*GameEvent)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeGameEvent)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeGameEvent))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &gameEventR{}
		}
		args[object.GamePickID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &gameEventR{}
			}

			args[obj.GamePickID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`game_picks`),
		qm.WhereIn(`game_picks.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load GamePick")
	}

	var resultSlice []*GamePick
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice GamePick")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for game_picks")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for game_picks")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.GamePick = foreign
		if foreign.R == nil {
			foreign.R = &gamePickR{}
		}
		foreign.R.GameEvents = append(foreign.R.GameEvents, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.GamePickID == foreign.ID {
				local.R.GamePick = foreign
				if foreign.R == nil {
					foreign.R = &gamePickR{}
				}
				foreign.R.GameEvents = append(foreign.R.GameEvents, local)
				break
			}
		}
	}

	return nil
}

// LoadMatchEvent allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (gameEventL) LoadMatchEvent(e boil.Executor, singular bool, maybeGameEvent interface{}, mods queries.Applicator) error {
	var slice []*GameEvent
	var object *GameEvent

	if singular {
		var ok bool
		object, ok = maybeGameEvent.(*GameEvent)
		if !ok {
			object = new(GameEvent)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeGameEvent)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeGameEvent))
			}
		}
	} else {
		s, ok := maybeGameEvent.(*[]*GameEvent)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeGameEvent)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeGameEvent))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &gameEventR{}
		}
		if !queries.IsNil(object.MatchEventID) {
			args[object.MatchEventID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &gameEventR{}
			}

			if !queries.IsNil(obj.MatchEventID) {
				args[obj.MatchEventID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`match_events`),
		qm.WhereIn(`match_events.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load MatchEvent")
	}

	var resultSlice []*MatchEvent
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice MatchEvent")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for match_events")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for match_events")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.MatchEvent = foreign
		if foreign.R == nil {
			foreign.R = &matchEventR{}
		}
		foreign.R.GameEvents = append(foreign.R.GameEvents, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.MatchEventID, foreign.ID) {
				local.R.MatchEvent = foreign
				if foreign.R == nil {
					foreign.R = &matchEventR{}
				}
				foreign.R.GameEvents = append(foreign.R.GameEvents, local)
				break
			}
		}
	}

	return nil
}

// LoadPlayer allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (gameEventL) LoadPlayer(e boil.Executor, singular bool, maybeGameEvent interface{}, mods queries.Applicator) error {
	var slice []*GameEvent
	var object *GameEvent

	if singular {
		var ok bool
		object, ok = maybeGameEvent.(*GameEvent)
		if !ok {
			object = new(GameEvent)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeGameEvent)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeGameEvent))
			}
		}
	} else {
		s, ok := maybeGameEvent.(*[]*GameEvent)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeGameEvent)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeGameEvent))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &gameEventR{}
		}
		args[object.PlayerID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &gameEventR{}
			}

			args[obj.PlayerID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`players`),
		qm.WhereIn(`players.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Player")
	}

	var resultSlice []*Player
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Player")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for players")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for players")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Player = foreign
		if foreign.R == nil {
			foreign.R = &playerR{}
		}
		foreign.R.GameEvents = append(foreign.R.GameEvents, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.PlayerID == foreign.ID {
				local.R.Player = foreign
				if foreign.R == nil {
					foreign.R = &playerR{}
				}
				foreign.R.GameEvents = append(foreign.R.GameEvents, local)
				break
			}
		}
	}

	return nil
}

// LoadPowerup allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (gameEventL) LoadPowerup(e boil.Executor, singular bool, maybeGameEvent interface{}, mods queries.Applicator) error {
	var slice []*GameEvent
	var object *GameEvent

	if singular {
		var ok bool
		object, ok = maybeGameEvent.(*GameEvent)
		if !ok {
			object = new(GameEvent)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeGameEvent)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeGameEvent))
			}
		}
	} else {
		s, ok := maybeGameEvent.(*[]*GameEvent)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeGameEvent)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeGameEvent))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &gameEventR{}
		}
		if !queries.IsNil(object.PowerupID) {
			args[object.PowerupID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &gameEventR{}
			}

			if !queries.IsNil(obj.PowerupID) {
				args[obj.PowerupID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`game_powerups`),
		qm.WhereIn(`game_powerups.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load GamePowerup")
	}

	var resultSlice []*GamePowerup
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice GamePowerup")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for game_powerups")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for game_powerups")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Powerup = foreign
		if foreign.R == nil {
			foreign.R = &gamePowerupR{}
		}
		foreign.R.PowerupGameEvents = append(foreign.R.PowerupGameEvents, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.PowerupID, foreign.ID) {
				local.R.Powerup = foreign
				if foreign.R == nil {
					foreign.R = &gamePowerupR{}
				}
				foreign.R.PowerupGameEvents = append(foreign.R.PowerupGameEvents, local)
				break
			}
		}
	}

	return nil
}

// LoadTeam allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (gameEventL) LoadTeam(e boil.Executor, singular bool, maybeGameEvent interface{}, mods queries.Applicator) error {
	var slice []*GameEvent
	var object *GameEvent

	if singular {
		var ok bool
		object, ok = maybeGameEvent.(*GameEvent)
		if !ok {
			object = new(GameEvent)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeGameEvent)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeGameEvent))
			}
		}
	} else {
		s, ok := maybeGameEvent.(*[]*GameEvent)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeGameEvent)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeGameEvent))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &gameEventR{}
		}
		args[object.TeamID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &gameEventR{}
			}

			args[obj.TeamID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`teams`),
		qm.WhereIn(`teams.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Team")
	}

	var resultSlice []*Team
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Team")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for teams")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for teams")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Team = foreign
		if foreign.R == nil {
			foreign.R = &teamR{}
		}
		foreign.R.GameEvents = append(foreign.R.GameEvents, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.TeamID == foreign.ID {
				local.R.Team = foreign
				if foreign.R == nil {
					foreign.R = &teamR{}
				}
				foreign.R.GameEvents = append(foreign.R.GameEvents, local)
				break
			}
		}
	}

	return nil
}

// SetGame of the gameEvent to the related item.
// Sets o.R.Game to related.
// Adds o to related.R.GameEvents.
func (o *GameEvent) SetGame(exec boil.Executor, insert bool, related *Game) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"game_events\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"game_id"}),
		strmangle.WhereClause("\"", "\"", 2, gameEventPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.GameID = related.ID
	if o.R == nil {
		o.R = &gameEventR{
			Game: related,
		}
	} else {
		o.R.Game = related
	}

	if related.R == nil {
		related.R = &gameR{
			GameEvents: GameEventSlice{o},
		}
	} else {
		related.R.GameEvents = append(related.R.GameEvents, o)
	}

	return nil
}

// SetGamePick of the gameEvent to the related item.
// Sets o.R.GamePick to related.
// Adds o to related.R.GameEvents.
func (o *GameEvent) SetGamePick(exec boil.Executor, insert bool, related *GamePick) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"game_events\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"game_pick_id"}),
		strmangle.WhereClause("\"", "\"", 2, gameEventPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.GamePickID = related.ID
	if o.R == nil {
		o.R = &gameEventR{
			GamePick: related,
		}
	} else {
		o.R.GamePick = related
	}

	if related.R == nil {
		related.R = &gamePickR{
			GameEvents: GameEventSlice{o},
		}
	} else {
		related.R.GameEvents = append(related.R.GameEvents, o)
	}

	return nil
}

// SetMatchEvent of the gameEvent to the related item.
// Sets o.R.MatchEvent to related.
// Adds o to related.R.GameEvents.
func (o *GameEvent) SetMatchEvent(exec boil.Executor, insert bool, related *MatchEvent) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"game_events\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"match_event_id"}),
		strmangle.WhereClause("\"", "\"", 2, gameEventPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.MatchEventID, related.ID)
	if o.R == nil {
		o.R = &gameEventR{
			MatchEvent: related,
		}
	} else {
		o.R.MatchEvent = related
	}

	if related.R == nil {
		related.R = &matchEventR{
			GameEvents: GameEventSlice{o},
		}
	} else {
		related.R.GameEvents = append(related.R.GameEvents, o)
	}

	return nil
}

// RemoveMatchEvent relationship.
// Sets o.R.MatchEvent to nil.
// Removes o from all passed in related items' relationships struct.
func (o *GameEvent) RemoveMatchEvent(exec boil.Executor, related *MatchEvent) error {
	var err error

	queries.SetScanner(&o.MatchEventID, nil)
	if _, err = o.Update(exec, boil.Whitelist("match_event_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.MatchEvent = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.GameEvents {
		if queries.Equal(o.MatchEventID, ri.MatchEventID) {
			continue
		}

		ln := len(related.R.GameEvents)
		if ln > 1 && i < ln-1 {
			related.R.GameEvents[i] = related.R.GameEvents[ln-1]
		}
		related.R.GameEvents = related.R.GameEvents[:ln-1]
		break
	}
	return nil
}

// SetPlayer of the gameEvent to the related item.
// Sets o.R.Player to related.
// Adds o to related.R.GameEvents.
func (o *GameEvent) SetPlayer(exec boil.Executor, insert bool, related *Player) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"game_events\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
		strmangle.WhereClause("\"", "\"", 2, gameEventPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.PlayerID = related.ID
	if o.R == nil {
		o.R = &gameEventR{
			Player: related,
		}
	} else {
		o.R.Player = related
	}

	if related.R == nil {
		related.R = &playerR{
			GameEvents: GameEventSlice{o},
		}
	} else {
		related.R.GameEvents = append(related.R.GameEvents, o)
	}

	return nil
}

// SetPowerup of the gameEvent to the related item.
// Sets o.R.Powerup to related.
// Adds o to related.R.PowerupGameEvents.
func (o *GameEvent) SetPowerup(exec boil.Executor, insert bool, related *GamePowerup) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"game_events\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"powerup_id"}),
		strmangle.WhereClause("\"", "\"", 2, gameEventPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.PowerupID, related.ID)
	if o.R == nil {
		o.R = &gameEventR{
			Powerup: related,
		}
	} else {
		o.R.Powerup = related
	}

	if related.R == nil {
		related.R = &gamePowerupR{
			PowerupGameEvents: GameEventSlice{o},
		}
	} else {
		related.R.PowerupGameEvents = append(related.R.PowerupGameEvents, o)
	}

	return nil
}

// RemovePowerup relationship.
// Sets o.R.Powerup to nil.
// Removes o from all passed in related items' relationships struct.
func (o *GameEvent) RemovePowerup(exec boil.Executor, related *GamePowerup) error {
	var err error

	queries.SetScanner(&o.PowerupID, nil)
	if _, err = o.Update(exec, boil.Whitelist("powerup_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Powerup = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.PowerupGameEvents {
		if queries.Equal(o.PowerupID, ri.PowerupID) {
			continue
		}

		ln := len(related.R.PowerupGameEvents)
		if ln > 1 && i < ln-1 {
			related.R.PowerupGameEvents[i] = related.R.PowerupGameEvents[ln-1]
		}
		related.R.PowerupGameEvents = related.R.PowerupGameEvents[:ln-1]
		break
	}
	return nil
}

// SetTeam of the gameEvent to the related item.
// Sets o.R.Team to related.
// Adds o to related.R.GameEvents.
func (o *GameEvent) SetTeam(exec boil.Executor, insert bool, related *Team) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"game_events\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"team_id"}),
		strmangle.WhereClause("\"", "\"", 2, gameEventPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.TeamID = related.ID
	if o.R == nil {
		o.R = &gameEventR{
			Team: related,
		}
	} else {
		o.R.Team = related
	}

	if related.R == nil {
		related.R = &teamR{
			GameEvents: GameEventSlice{o},
		}
	} else {
		related.R.GameEvents = append(related.R.GameEvents, o)
	}

	return nil
}

// GameEvents retrieves all the records using an executor.
func GameEvents(mods ...qm.QueryMod) gameEventQuery {
	mods = append(mods, qm.From("\"game_events\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"game_events\".*"})
	}

	return gameEventQuery{q}
}

// FindGameEvent retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindGameEvent(exec boil.Executor, iD string, selectCols ...string) (*GameEvent, error) {
	gameEventObj := &GameEvent{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"game_events\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(nil, exec, gameEventObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "schema: unable to select from game_events")
	}

	return gameEventObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *GameEvent) Insert(exec boil.Executor, columns boil.Columns) error {
	if o == nil {
		return errors.New("schema: no game_events provided for insertion")
	}

	var err error
	currTime := time.Now().In(boil.GetLocation())

	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}

	nzDefaults := queries.NonZeroDefaultSet(gameEventColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	gameEventInsertCacheMut.RLock()
	cache, cached := gameEventInsertCache[key]
	gameEventInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			gameEventAllColumns,
			gameEventColumnsWithDefault,
			gameEventColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(gameEventType, gameEventMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(gameEventType, gameEventMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"game_events\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"game_events\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "schema: unable to insert into game_events")
	}

	if !cached {
		gameEventInsertCacheMut.Lock()
		gameEventInsertCache[key] = cache
		gameEventInsertCacheMut.Unlock()
	}

	return nil
}

// Update uses an executor to update the GameEvent.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *GameEvent) Update(exec boil.Executor, columns boil.Columns) (int64, error) {
	var err error
	key := makeCacheKey(columns, nil)
	gameEventUpdateCacheMut.RLock()
	cache, cached := gameEventUpdateCache[key]
	gameEventUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			gameEventAllColumns,
			gameEventPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("schema: unable to update game_events, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"game_events\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, gameEventPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(gameEventType, gameEventMapping, append(wl, gameEventPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	var result sql.Result
	result, err = exec.Exec(cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to update game_events row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "schema: failed to get rows affected by update for game_events")
	}

	if !cached {
		gameEventUpdateCacheMut.Lock()
		gameEventUpdateCache[key] = cache
		gameEventUpdateCacheMut.Unlock()
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values.
func (q gameEventQuery) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to update all for game_events")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to retrieve rows affected for game_events")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o GameEventSlice) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("schema: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), gameEventPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"game_events\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, gameEventPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to update all in gameEvent slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to retrieve rows affected all in update all gameEvent")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *GameEvent) Upsert(exec boil.Executor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("schema: no game_events provided for upsert")
	}
	currTime := time.Now().In(boil.GetLocation())

	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}

	nzDefaults := queries.NonZeroDefaultSet(gameEventColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	gameEventUpsertCacheMut.RLock()
	cache, cached := gameEventUpsertCache[key]
	gameEventUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			gameEventAllColumns,
			gameEventColumnsWithDefault,
			gameEventColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			gameEventAllColumns,
			gameEventPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("schema: unable to upsert game_events, could not build update column list")
		}

		ret := strmangle.SetComplement(gameEventAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(gameEventPrimaryKeyColumns) == 0 {
				return errors.New("schema: unable to upsert game_events, could not build conflict column list")
			}

			conflict = make([]string, len(gameEventPrimaryKeyColumns))
			copy(conflict, gameEventPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"game_events\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(gameEventType, gameEventMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(gameEventType, gameEventMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "schema: unable to upsert game_events")
	}

	if !cached {
		gameEventUpsertCacheMut.Lock()
		gameEventUpsertCache[key] = cache
		gameEventUpsertCacheMut.Unlock()
	}

	return nil
}

// Delete deletes a single GameEvent record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *GameEvent) Delete(exec boil.Executor) (int64, error) {
	if o == nil {
		return 0, errors.New("schema: no GameEvent provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), gameEventPrimaryKeyMapping)
	sql := "DELETE FROM \"game_events\" WHERE \"id\"=$1"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to delete from game_events")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "schema: failed to get rows affected by delete for game_events")
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q gameEventQuery) DeleteAll(exec boil.Executor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("schema: no gameEventQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to delete all from game_events")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "schema: failed to get rows affected by deleteall for game_events")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o GameEventSlice) DeleteAll(exec boil.Executor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), gameEventPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"game_events\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, gameEventPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to delete all from gameEvent slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "schema: failed to get rows affected by deleteall for game_events")
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *GameEvent) Reload(exec boil.Executor) error {
	ret, err := FindGameEvent(exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *GameEventSlice) ReloadAll(exec boil.Executor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := GameEventSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), gameEventPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"game_events\".* FROM \"game_events\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, gameEventPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(nil, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "schema: unable to reload all in GameEventSlice")
	}

	*o = slice

	return nil
}

// GameEventExists checks if the GameEvent row exists.
func GameEventExists(exec boil.Executor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"game_events\" where \"id\"=$1 limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}
	row := exec.QueryRow(sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "schema: unable to check if game_events exists")
	}

	return exists, nil
}

// Exists checks if the GameEvent row exists.
func (o *GameEvent) Exists(exec boil.Executor) (bool, error) {
	return GameEventExists(exec, o.ID)
}
