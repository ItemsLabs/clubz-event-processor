// Code generated by SQLBoiler 4.16.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package schema

import (
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// PlayerBucket is an object representing the database table.
type PlayerBucket struct {
	ID               string      `boil:"id" json:"id" toml:"id" yaml:"id"`
	CreatedAt        time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt        time.Time   `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`
	FirstName        string      `boil:"first_name" json:"first_name" toml:"first_name" yaml:"first_name"`
	LastName         string      `boil:"last_name" json:"last_name" toml:"last_name" yaml:"last_name"`
	TeamID           string      `boil:"team_id" json:"team_id" toml:"team_id" yaml:"team_id"`
	Age              int         `boil:"age" json:"age" toml:"age" yaml:"age"`
	Bronze           null.Bool   `boil:"bronze" json:"bronze,omitempty" toml:"bronze" yaml:"bronze,omitempty"`
	Common           int         `boil:"common" json:"common" toml:"common" yaml:"common"`
	CountryID        null.String `boil:"country_id" json:"country_id,omitempty" toml:"country_id" yaml:"country_id,omitempty"`
	Diamond          null.Bool   `boil:"diamond" json:"diamond,omitempty" toml:"diamond" yaml:"diamond,omitempty"`
	GamePosition     null.String `boil:"game_position" json:"game_position,omitempty" toml:"game_position" yaml:"game_position,omitempty"`
	Gold             null.Bool   `boil:"gold" json:"gold,omitempty" toml:"gold" yaml:"gold,omitempty"`
	Legendary        int         `boil:"legendary" json:"legendary" toml:"legendary" yaml:"legendary"`
	Platinum         null.Bool   `boil:"platinum" json:"platinum,omitempty" toml:"platinum" yaml:"platinum,omitempty"`
	Position         null.String `boil:"position" json:"position,omitempty" toml:"position" yaml:"position,omitempty"`
	Rare             int         `boil:"rare" json:"rare" toml:"rare" yaml:"rare"`
	RealPopularity   int         `boil:"real_popularity" json:"real_popularity" toml:"real_popularity" yaml:"real_popularity"`
	Silver           null.Bool   `boil:"silver" json:"silver,omitempty" toml:"silver" yaml:"silver,omitempty"`
	UltraRare        int         `boil:"ultra_rare" json:"ultra_rare" toml:"ultra_rare" yaml:"ultra_rare"`
	Uncommon         int         `boil:"uncommon" json:"uncommon" toml:"uncommon" yaml:"uncommon"`
	UsablePopularity int         `boil:"usable_popularity" json:"usable_popularity" toml:"usable_popularity" yaml:"usable_popularity"`

	R *playerBucketR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L playerBucketL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var PlayerBucketColumns = struct {
	ID               string
	CreatedAt        string
	UpdatedAt        string
	FirstName        string
	LastName         string
	TeamID           string
	Age              string
	Bronze           string
	Common           string
	CountryID        string
	Diamond          string
	GamePosition     string
	Gold             string
	Legendary        string
	Platinum         string
	Position         string
	Rare             string
	RealPopularity   string
	Silver           string
	UltraRare        string
	Uncommon         string
	UsablePopularity string
}{
	ID:               "id",
	CreatedAt:        "created_at",
	UpdatedAt:        "updated_at",
	FirstName:        "first_name",
	LastName:         "last_name",
	TeamID:           "team_id",
	Age:              "age",
	Bronze:           "bronze",
	Common:           "common",
	CountryID:        "country_id",
	Diamond:          "diamond",
	GamePosition:     "game_position",
	Gold:             "gold",
	Legendary:        "legendary",
	Platinum:         "platinum",
	Position:         "position",
	Rare:             "rare",
	RealPopularity:   "real_popularity",
	Silver:           "silver",
	UltraRare:        "ultra_rare",
	Uncommon:         "uncommon",
	UsablePopularity: "usable_popularity",
}

var PlayerBucketTableColumns = struct {
	ID               string
	CreatedAt        string
	UpdatedAt        string
	FirstName        string
	LastName         string
	TeamID           string
	Age              string
	Bronze           string
	Common           string
	CountryID        string
	Diamond          string
	GamePosition     string
	Gold             string
	Legendary        string
	Platinum         string
	Position         string
	Rare             string
	RealPopularity   string
	Silver           string
	UltraRare        string
	Uncommon         string
	UsablePopularity string
}{
	ID:               "player_bucket.id",
	CreatedAt:        "player_bucket.created_at",
	UpdatedAt:        "player_bucket.updated_at",
	FirstName:        "player_bucket.first_name",
	LastName:         "player_bucket.last_name",
	TeamID:           "player_bucket.team_id",
	Age:              "player_bucket.age",
	Bronze:           "player_bucket.bronze",
	Common:           "player_bucket.common",
	CountryID:        "player_bucket.country_id",
	Diamond:          "player_bucket.diamond",
	GamePosition:     "player_bucket.game_position",
	Gold:             "player_bucket.gold",
	Legendary:        "player_bucket.legendary",
	Platinum:         "player_bucket.platinum",
	Position:         "player_bucket.position",
	Rare:             "player_bucket.rare",
	RealPopularity:   "player_bucket.real_popularity",
	Silver:           "player_bucket.silver",
	UltraRare:        "player_bucket.ultra_rare",
	Uncommon:         "player_bucket.uncommon",
	UsablePopularity: "player_bucket.usable_popularity",
}

// Generated where

type whereHelpernull_Bool struct{ field string }

func (w whereHelpernull_Bool) EQ(x null.Bool) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Bool) NEQ(x null.Bool) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Bool) LT(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Bool) LTE(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Bool) GT(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Bool) GTE(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpernull_Bool) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Bool) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

var PlayerBucketWhere = struct {
	ID               whereHelperstring
	CreatedAt        whereHelpertime_Time
	UpdatedAt        whereHelpertime_Time
	FirstName        whereHelperstring
	LastName         whereHelperstring
	TeamID           whereHelperstring
	Age              whereHelperint
	Bronze           whereHelpernull_Bool
	Common           whereHelperint
	CountryID        whereHelpernull_String
	Diamond          whereHelpernull_Bool
	GamePosition     whereHelpernull_String
	Gold             whereHelpernull_Bool
	Legendary        whereHelperint
	Platinum         whereHelpernull_Bool
	Position         whereHelpernull_String
	Rare             whereHelperint
	RealPopularity   whereHelperint
	Silver           whereHelpernull_Bool
	UltraRare        whereHelperint
	Uncommon         whereHelperint
	UsablePopularity whereHelperint
}{
	ID:               whereHelperstring{field: "\"player_bucket\".\"id\""},
	CreatedAt:        whereHelpertime_Time{field: "\"player_bucket\".\"created_at\""},
	UpdatedAt:        whereHelpertime_Time{field: "\"player_bucket\".\"updated_at\""},
	FirstName:        whereHelperstring{field: "\"player_bucket\".\"first_name\""},
	LastName:         whereHelperstring{field: "\"player_bucket\".\"last_name\""},
	TeamID:           whereHelperstring{field: "\"player_bucket\".\"team_id\""},
	Age:              whereHelperint{field: "\"player_bucket\".\"age\""},
	Bronze:           whereHelpernull_Bool{field: "\"player_bucket\".\"bronze\""},
	Common:           whereHelperint{field: "\"player_bucket\".\"common\""},
	CountryID:        whereHelpernull_String{field: "\"player_bucket\".\"country_id\""},
	Diamond:          whereHelpernull_Bool{field: "\"player_bucket\".\"diamond\""},
	GamePosition:     whereHelpernull_String{field: "\"player_bucket\".\"game_position\""},
	Gold:             whereHelpernull_Bool{field: "\"player_bucket\".\"gold\""},
	Legendary:        whereHelperint{field: "\"player_bucket\".\"legendary\""},
	Platinum:         whereHelpernull_Bool{field: "\"player_bucket\".\"platinum\""},
	Position:         whereHelpernull_String{field: "\"player_bucket\".\"position\""},
	Rare:             whereHelperint{field: "\"player_bucket\".\"rare\""},
	RealPopularity:   whereHelperint{field: "\"player_bucket\".\"real_popularity\""},
	Silver:           whereHelpernull_Bool{field: "\"player_bucket\".\"silver\""},
	UltraRare:        whereHelperint{field: "\"player_bucket\".\"ultra_rare\""},
	Uncommon:         whereHelperint{field: "\"player_bucket\".\"uncommon\""},
	UsablePopularity: whereHelperint{field: "\"player_bucket\".\"usable_popularity\""},
}

// PlayerBucketRels is where relationship names are stored.
var PlayerBucketRels = struct {
	Country string
	Team    string
}{
	Country: "Country",
	Team:    "Team",
}

// playerBucketR is where relationships are stored.
type playerBucketR struct {
	Country *Country `boil:"Country" json:"Country" toml:"Country" yaml:"Country"`
	Team    *Team    `boil:"Team" json:"Team" toml:"Team" yaml:"Team"`
}

// NewStruct creates a new relationship struct
func (*playerBucketR) NewStruct() *playerBucketR {
	return &playerBucketR{}
}

func (r *playerBucketR) GetCountry() *Country {
	if r == nil {
		return nil
	}
	return r.Country
}

func (r *playerBucketR) GetTeam() *Team {
	if r == nil {
		return nil
	}
	return r.Team
}

// playerBucketL is where Load methods for each relationship are stored.
type playerBucketL struct{}

var (
	playerBucketAllColumns            = []string{"id", "created_at", "updated_at", "first_name", "last_name", "team_id", "age", "bronze", "common", "country_id", "diamond", "game_position", "gold", "legendary", "platinum", "position", "rare", "real_popularity", "silver", "ultra_rare", "uncommon", "usable_popularity"}
	playerBucketColumnsWithoutDefault = []string{"id", "created_at", "updated_at", "first_name", "last_name", "team_id", "age", "common", "legendary", "rare", "real_popularity", "ultra_rare", "uncommon", "usable_popularity"}
	playerBucketColumnsWithDefault    = []string{"bronze", "country_id", "diamond", "game_position", "gold", "platinum", "position", "silver"}
	playerBucketPrimaryKeyColumns     = []string{"id"}
	playerBucketGeneratedColumns      = []string{}
)

type (
	// PlayerBucketSlice is an alias for a slice of pointers to PlayerBucket.
	// This should almost always be used instead of []PlayerBucket.
	PlayerBucketSlice []*PlayerBucket

	playerBucketQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	playerBucketType                 = reflect.TypeOf(&PlayerBucket{})
	playerBucketMapping              = queries.MakeStructMapping(playerBucketType)
	playerBucketPrimaryKeyMapping, _ = queries.BindMapping(playerBucketType, playerBucketMapping, playerBucketPrimaryKeyColumns)
	playerBucketInsertCacheMut       sync.RWMutex
	playerBucketInsertCache          = make(map[string]insertCache)
	playerBucketUpdateCacheMut       sync.RWMutex
	playerBucketUpdateCache          = make(map[string]updateCache)
	playerBucketUpsertCacheMut       sync.RWMutex
	playerBucketUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// One returns a single playerBucket record from the query.
func (q playerBucketQuery) One(exec boil.Executor) (*PlayerBucket, error) {
	o := &PlayerBucket{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(nil, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "schema: failed to execute a one query for player_bucket")
	}

	return o, nil
}

// All returns all PlayerBucket records from the query.
func (q playerBucketQuery) All(exec boil.Executor) (PlayerBucketSlice, error) {
	var o []*PlayerBucket

	err := q.Bind(nil, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "schema: failed to assign all query results to PlayerBucket slice")
	}

	return o, nil
}

// Count returns the count of all PlayerBucket records in the query.
func (q playerBucketQuery) Count(exec boil.Executor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "schema: failed to count player_bucket rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q playerBucketQuery) Exists(exec boil.Executor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "schema: failed to check if player_bucket exists")
	}

	return count > 0, nil
}

// Country pointed to by the foreign key.
func (o *PlayerBucket) Country(mods ...qm.QueryMod) countryQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.CountryID),
	}

	queryMods = append(queryMods, mods...)

	return Countries(queryMods...)
}

// Team pointed to by the foreign key.
func (o *PlayerBucket) Team(mods ...qm.QueryMod) teamQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.TeamID),
	}

	queryMods = append(queryMods, mods...)

	return Teams(queryMods...)
}

// LoadCountry allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (playerBucketL) LoadCountry(e boil.Executor, singular bool, maybePlayerBucket interface{}, mods queries.Applicator) error {
	var slice []*PlayerBucket
	var object *PlayerBucket

	if singular {
		var ok bool
		object, ok = maybePlayerBucket.(*PlayerBucket)
		if !ok {
			object = new(PlayerBucket)
			ok = queries.SetFromEmbeddedStruct(&object, &maybePlayerBucket)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybePlayerBucket))
			}
		}
	} else {
		s, ok := maybePlayerBucket.(*[]*PlayerBucket)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybePlayerBucket)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybePlayerBucket))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &playerBucketR{}
		}
		if !queries.IsNil(object.CountryID) {
			args[object.CountryID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerBucketR{}
			}

			if !queries.IsNil(obj.CountryID) {
				args[obj.CountryID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`countries`),
		qm.WhereIn(`countries.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Country")
	}

	var resultSlice []*Country
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Country")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for countries")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for countries")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Country = foreign
		if foreign.R == nil {
			foreign.R = &countryR{}
		}
		foreign.R.PlayerBuckets = append(foreign.R.PlayerBuckets, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.CountryID, foreign.ID) {
				local.R.Country = foreign
				if foreign.R == nil {
					foreign.R = &countryR{}
				}
				foreign.R.PlayerBuckets = append(foreign.R.PlayerBuckets, local)
				break
			}
		}
	}

	return nil
}

// LoadTeam allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (playerBucketL) LoadTeam(e boil.Executor, singular bool, maybePlayerBucket interface{}, mods queries.Applicator) error {
	var slice []*PlayerBucket
	var object *PlayerBucket

	if singular {
		var ok bool
		object, ok = maybePlayerBucket.(*PlayerBucket)
		if !ok {
			object = new(PlayerBucket)
			ok = queries.SetFromEmbeddedStruct(&object, &maybePlayerBucket)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybePlayerBucket))
			}
		}
	} else {
		s, ok := maybePlayerBucket.(*[]*PlayerBucket)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybePlayerBucket)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybePlayerBucket))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &playerBucketR{}
		}
		args[object.TeamID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerBucketR{}
			}

			args[obj.TeamID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`teams`),
		qm.WhereIn(`teams.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Team")
	}

	var resultSlice []*Team
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Team")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for teams")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for teams")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Team = foreign
		if foreign.R == nil {
			foreign.R = &teamR{}
		}
		foreign.R.PlayerBuckets = append(foreign.R.PlayerBuckets, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.TeamID == foreign.ID {
				local.R.Team = foreign
				if foreign.R == nil {
					foreign.R = &teamR{}
				}
				foreign.R.PlayerBuckets = append(foreign.R.PlayerBuckets, local)
				break
			}
		}
	}

	return nil
}

// SetCountry of the playerBucket to the related item.
// Sets o.R.Country to related.
// Adds o to related.R.PlayerBuckets.
func (o *PlayerBucket) SetCountry(exec boil.Executor, insert bool, related *Country) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"player_bucket\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"country_id"}),
		strmangle.WhereClause("\"", "\"", 2, playerBucketPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.CountryID, related.ID)
	if o.R == nil {
		o.R = &playerBucketR{
			Country: related,
		}
	} else {
		o.R.Country = related
	}

	if related.R == nil {
		related.R = &countryR{
			PlayerBuckets: PlayerBucketSlice{o},
		}
	} else {
		related.R.PlayerBuckets = append(related.R.PlayerBuckets, o)
	}

	return nil
}

// RemoveCountry relationship.
// Sets o.R.Country to nil.
// Removes o from all passed in related items' relationships struct.
func (o *PlayerBucket) RemoveCountry(exec boil.Executor, related *Country) error {
	var err error

	queries.SetScanner(&o.CountryID, nil)
	if _, err = o.Update(exec, boil.Whitelist("country_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Country = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.PlayerBuckets {
		if queries.Equal(o.CountryID, ri.CountryID) {
			continue
		}

		ln := len(related.R.PlayerBuckets)
		if ln > 1 && i < ln-1 {
			related.R.PlayerBuckets[i] = related.R.PlayerBuckets[ln-1]
		}
		related.R.PlayerBuckets = related.R.PlayerBuckets[:ln-1]
		break
	}
	return nil
}

// SetTeam of the playerBucket to the related item.
// Sets o.R.Team to related.
// Adds o to related.R.PlayerBuckets.
func (o *PlayerBucket) SetTeam(exec boil.Executor, insert bool, related *Team) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"player_bucket\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"team_id"}),
		strmangle.WhereClause("\"", "\"", 2, playerBucketPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.TeamID = related.ID
	if o.R == nil {
		o.R = &playerBucketR{
			Team: related,
		}
	} else {
		o.R.Team = related
	}

	if related.R == nil {
		related.R = &teamR{
			PlayerBuckets: PlayerBucketSlice{o},
		}
	} else {
		related.R.PlayerBuckets = append(related.R.PlayerBuckets, o)
	}

	return nil
}

// PlayerBuckets retrieves all the records using an executor.
func PlayerBuckets(mods ...qm.QueryMod) playerBucketQuery {
	mods = append(mods, qm.From("\"player_bucket\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"player_bucket\".*"})
	}

	return playerBucketQuery{q}
}

// FindPlayerBucket retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindPlayerBucket(exec boil.Executor, iD string, selectCols ...string) (*PlayerBucket, error) {
	playerBucketObj := &PlayerBucket{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"player_bucket\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(nil, exec, playerBucketObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "schema: unable to select from player_bucket")
	}

	return playerBucketObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *PlayerBucket) Insert(exec boil.Executor, columns boil.Columns) error {
	if o == nil {
		return errors.New("schema: no player_bucket provided for insertion")
	}

	var err error
	currTime := time.Now().In(boil.GetLocation())

	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}
	if o.UpdatedAt.IsZero() {
		o.UpdatedAt = currTime
	}

	nzDefaults := queries.NonZeroDefaultSet(playerBucketColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	playerBucketInsertCacheMut.RLock()
	cache, cached := playerBucketInsertCache[key]
	playerBucketInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			playerBucketAllColumns,
			playerBucketColumnsWithDefault,
			playerBucketColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(playerBucketType, playerBucketMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(playerBucketType, playerBucketMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"player_bucket\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"player_bucket\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "schema: unable to insert into player_bucket")
	}

	if !cached {
		playerBucketInsertCacheMut.Lock()
		playerBucketInsertCache[key] = cache
		playerBucketInsertCacheMut.Unlock()
	}

	return nil
}

// Update uses an executor to update the PlayerBucket.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *PlayerBucket) Update(exec boil.Executor, columns boil.Columns) (int64, error) {
	currTime := time.Now().In(boil.GetLocation())

	o.UpdatedAt = currTime

	var err error
	key := makeCacheKey(columns, nil)
	playerBucketUpdateCacheMut.RLock()
	cache, cached := playerBucketUpdateCache[key]
	playerBucketUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			playerBucketAllColumns,
			playerBucketPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("schema: unable to update player_bucket, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"player_bucket\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, playerBucketPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(playerBucketType, playerBucketMapping, append(wl, playerBucketPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	var result sql.Result
	result, err = exec.Exec(cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to update player_bucket row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "schema: failed to get rows affected by update for player_bucket")
	}

	if !cached {
		playerBucketUpdateCacheMut.Lock()
		playerBucketUpdateCache[key] = cache
		playerBucketUpdateCacheMut.Unlock()
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values.
func (q playerBucketQuery) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to update all for player_bucket")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to retrieve rows affected for player_bucket")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o PlayerBucketSlice) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("schema: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), playerBucketPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"player_bucket\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, playerBucketPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to update all in playerBucket slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to retrieve rows affected all in update all playerBucket")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *PlayerBucket) Upsert(exec boil.Executor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("schema: no player_bucket provided for upsert")
	}
	currTime := time.Now().In(boil.GetLocation())

	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}
	o.UpdatedAt = currTime

	nzDefaults := queries.NonZeroDefaultSet(playerBucketColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	playerBucketUpsertCacheMut.RLock()
	cache, cached := playerBucketUpsertCache[key]
	playerBucketUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			playerBucketAllColumns,
			playerBucketColumnsWithDefault,
			playerBucketColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			playerBucketAllColumns,
			playerBucketPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("schema: unable to upsert player_bucket, could not build update column list")
		}

		ret := strmangle.SetComplement(playerBucketAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(playerBucketPrimaryKeyColumns) == 0 {
				return errors.New("schema: unable to upsert player_bucket, could not build conflict column list")
			}

			conflict = make([]string, len(playerBucketPrimaryKeyColumns))
			copy(conflict, playerBucketPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"player_bucket\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(playerBucketType, playerBucketMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(playerBucketType, playerBucketMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "schema: unable to upsert player_bucket")
	}

	if !cached {
		playerBucketUpsertCacheMut.Lock()
		playerBucketUpsertCache[key] = cache
		playerBucketUpsertCacheMut.Unlock()
	}

	return nil
}

// Delete deletes a single PlayerBucket record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *PlayerBucket) Delete(exec boil.Executor) (int64, error) {
	if o == nil {
		return 0, errors.New("schema: no PlayerBucket provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), playerBucketPrimaryKeyMapping)
	sql := "DELETE FROM \"player_bucket\" WHERE \"id\"=$1"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to delete from player_bucket")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "schema: failed to get rows affected by delete for player_bucket")
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q playerBucketQuery) DeleteAll(exec boil.Executor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("schema: no playerBucketQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to delete all from player_bucket")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "schema: failed to get rows affected by deleteall for player_bucket")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o PlayerBucketSlice) DeleteAll(exec boil.Executor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), playerBucketPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"player_bucket\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, playerBucketPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "schema: unable to delete all from playerBucket slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "schema: failed to get rows affected by deleteall for player_bucket")
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *PlayerBucket) Reload(exec boil.Executor) error {
	ret, err := FindPlayerBucket(exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *PlayerBucketSlice) ReloadAll(exec boil.Executor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := PlayerBucketSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), playerBucketPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"player_bucket\".* FROM \"player_bucket\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, playerBucketPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(nil, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "schema: unable to reload all in PlayerBucketSlice")
	}

	*o = slice

	return nil
}

// PlayerBucketExists checks if the PlayerBucket row exists.
func PlayerBucketExists(exec boil.Executor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"player_bucket\" where \"id\"=$1 limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}
	row := exec.QueryRow(sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "schema: unable to check if player_bucket exists")
	}

	return exists, nil
}

// Exists checks if the PlayerBucket row exists.
func (o *PlayerBucket) Exists(exec boil.Executor) (bool, error) {
	return PlayerBucketExists(exec, o.ID)
}
